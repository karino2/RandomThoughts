import{_ as e,c as i,a as o,o as n}from"./app-CHbCxg9g.js";const r={};function c(t,a){return n(),i("div",null,[...a[0]||(a[0]=[o('<p>[[並列プログラム]]</p><p><a href="https://amzn.to/3Sxl1Ed" target="_blank" rel="noopener noreferrer">Amazon: The Art of Multiprocessor Programming (2nd edition)</a>に第二版があるが、 自分はかつて第一版を買ったまま読まずに来てもったいないので第一版を読んでいる。（2023年現在）</p><p>JavaのCPUがたくさんある場合のプログラムの話で、 ロックフリーなアルゴリズムなどの話の教科書的な位置づけと思う。</p><p>[[1024cores]]ではこの本に無いが良く使うようなアルゴリズムがいろいろ紹介されているので、 少しこの本では不足を感じるけれど、不足があるのは内容がダメという事では無く、 むしろ自分の手持ちの中ではこの分野についてもっともちゃんと書いてある本と言える。</p><p>個人的には2010年代の初頭に勉強会でこの本をやろう、となって最初の方で挫折した過去がある。 あの当時は「こりゃ人類には難しすぎて無理だ」と思ったが、 2023年現在ではなかなか面白く読める事に気づいてちょくちょく読んでいる。</p><p>あまり先頭から全部読もうという気はなくて、仕事に役に立ちそうなあたりだけを読むつもり。 この本はなんかそういう読み方の方が挫折もしづらくていい気もする。</p><h2 id="_7章のspin-lock" tabindex="-1"><a class="header-anchor" href="#_7章のspin-lock"><span>7章のSpin Lock</span></a></h2><p>仕事でこれまでロックで扱っていたのがfast passでパフォーマンスが出なくて困っていたので、 fast passではロックしなくてもいいように変えたいと思っている。</p><p>そこでスピンロックの周辺の理解を深めてなんとか出来ないか？と考えてこの章を読み始めた。</p><p>7章のSpin Lockは2章のLockの話の続きになっているので2章も読む必要がある。 2章はatomic variableを使ってどうロックを実現するか、みたいな内容。</p><p>Lockはいろいろ勉強になった。</p><h2 id="_8章は読まなくてもいいかなぁ" tabindex="-1"><a class="header-anchor" href="#_8章は読まなくてもいいかなぁ"><span>8章は読まなくてもいいかなぁ</span></a></h2><p>8章は読んだが、割と普通のlockでreader-writer lockを作るとかそういう話で、しかもちょっと実装がおかしい気がするがerrataとかも見つからなかったのでそんなに深くは読まずに先に進む事に。</p><h2 id="_9章linked-listを発展させていく" tabindex="-1"><a class="header-anchor" href="#_9章linked-listを発展させていく"><span>9章Linked-Listを発展させていく</span></a></h2><p>Coarse grainedから始めて最終的にLock Freeな実装にする、というのをやる。 中身はSetをLinked Listで実装する、みたいな感じで、containsとaddとremoveを提供する。</p><h3 id="基本的なアルゴリズム" tabindex="-1"><a class="header-anchor" href="#基本的なアルゴリズム"><span>基本的なアルゴリズム</span></a></h3><ul><li>coarse grained lock</li><li>fine grained lock</li><li>optimistic synchronization</li><li>lazy synchronization</li><li>non-blocking synchronization</li></ul><p>と進む。</p><p>fine grainedはlock couplingで順番にlockしていく奴。これは一度には少数のノードしかlockされないけれど、lockの回数自体はたくさん呼ばれる。</p><p>Optimisticはlockを取得せずに目的のノードまで進み、predとcurrをlockしたあとにもう一回最初から確認してたどり着けるかを確認する。 二回トラバースするけどlockは目的の周辺しかしないというメリットがある。</p><p>lazy synchronizationはノードの削除をマークしてlogicalに削除するのと、そのあとにphysicalに削除するのを分けるというもの。 こうすると、optimisticでlockしたあとに全部なめないといけなかったのが、 predとcurの確認だけでよくなる。 predとcurをlockする事はoptimistic lockと同様なのに注目。</p><p>最後のnon-blockingはlockなしで、フラグとreferenceのアトミックな操作を使って、lazy synchronizationと似たような事をやる。 nextにmarkのフラグとリファレンスを持たせて、 あとはだいたいlazy synchronizationと同じ構造だが、今回はlockを持ってないのでpredやcurrが変更されうる。 だから道中で見つけたマークされたノードはみんなが削除していく。 たまに他のスレッドとぶつかると最初からなめ直しが走る。</p><h3 id="雑感" tabindex="-1"><a class="header-anchor" href="#雑感"><span>雑感</span></a></h3><p>lazy synchronizationやnon-blockingはこれであってるかどうかの判断は難しい。 一見良さそうな気もするけれど、本当にいいかは自信が持てないし、 こうしないといけないというのも正確には理解出来ていない。</p><p>lazy synchronizationとnon-blockingは知らない内容だった気もする。どこかで読んだ事あるかもしれないが少なくとも覚えてない。 こういうアイデアを学んでおくのは有意義だと思うので、良い勉強になった。</p><p>また、linearization pointとかstarvation freeとかを復習するべく2章とかも結構読んだ。こういうのがちゃんと書いてあるのは教科書の良い所だが、indexにページ数すら書いてないのはダメじゃね？とも思う。まぁ古い本だからなぁ。</p><p>なお、Javaは楽だな、って気はするね。C++はGC無いので厳しい。</p><h2 id="_10章、queue" tabindex="-1"><a class="header-anchor" href="#_10章、queue"><span>10章、Queue</span></a></h2><p>とりあえず10.4まで読んだが、boundedとunboundedのfine grainedなLockを使った実装の話。 この後Lock Freeに進むっぽいが、9章の続きというよりは9章と並列の内容という感じはする。 11章はスタックとあるので、これも同じような話なのかなぁ。</p><p>Lock Freeはたぶん新しい内容があるっぽい（というかその後ABA問題の話が続くっぽいのは目次からわかる）が、 そのお膳立ての話に新しい事があまり無いのは読んでいてちょっとだるさはある。</p>',30)])])}const s=e(r,[["render",c]]),l=JSON.parse('{"path":"/%E3%80%90%E6%9B%B8%E7%B1%8D%E3%80%91TheArtOfMultiprocessorProgramming.html","title":"","lang":"en-US","frontmatter":{},"git":{"updatedTime":1701266729000,"contributors":[{"name":"Kazuma Arino","username":"","email":"hogeika2@gmail.com","commits":4}],"changelog":[{"hash":"8fe222a892a8ad03b3a1752db3e0853cd96ede10","time":1701266729000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"8a0154f2734f838b4ed368c3afecbbcac1492751","time":1701000844000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"ea1e284c294afb4250e59dd796f4ffccc6e4848d","time":1700035528000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"4a1a02c8fb8ca38362673483355bec315608542e","time":1699766641000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"}]},"filePathRelative":"【書籍】TheArtOfMultiprocessorProgramming.md"}');export{s as comp,l as data};
