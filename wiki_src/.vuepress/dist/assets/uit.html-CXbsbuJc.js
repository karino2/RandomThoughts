import{_ as a,c as e,a as t,o as n}from"./app-CHiHTJW6.js";const s={};function p(r,i){return n(),e("div",null,[...i[0]||(i[0]=[t(`<p>Unique it, 略してuit。gitを参考に考えたファイル管理システム。 すべてのファイルのハッシュを計算して、ハッシュが一致しているファイルは一つだけ実体を持ち、 重複ファイルを消していくようなシステム。</p><h2 id="リンク" tabindex="-1"><a class="header-anchor" href="#リンク"><span>リンク</span></a></h2><ul><li><a href="https://github.com/karino2/uit" target="_blank" rel="noopener noreferrer">karino2/uit: Unique it file sync and manage system.</a></li><li>[[FSharp]]</li><li>[[自作アプリ]]</li></ul><p>以下はブログに書いたメモとか作業ログ</p><ul><li><a href="https://karino2.github.io/2020/11/12/saikyou_file_sync.html" target="_blank" rel="noopener noreferrer">ぼくのかんがえたさいきょうのファイルsyncシステム - なーんだ、ただの水たまりじゃないか</a></li><li><a href="https://karino2.github.io/2020/12/11/uit_memo_1.html" target="_blank" rel="noopener noreferrer">uitに関するメモ その1 - なーんだ、ただの水たまりじゃないか</a></li><li><a href="https://karino2.github.io/2020/12/20/uit_memo_2.html" target="_blank" rel="noopener noreferrer">uitメモ2、ローカルで変更された場合についての考察など - なーんだ、ただの水たまりじゃないか</a></li></ul><hr><p>以下は開発メモ</p><h2 id="todo" tabindex="-1"><a class="header-anchor" href="#todo"><span>TODO</span></a></h2><ul><li>フォルダ以下のlinkファイルだけを全部削除するコマンドを実装</li><li>メタ情報と実際のファイルのタイムスタンプを比較して違うファイルの一覧を表示する機能 <ul><li>ファイル側から見るstatと、ハッシュ側から見るhstatを作りたい</li><li>不整合があった時にこれらのデータを処理するコマンドを作りたい</li></ul></li><li>initが不完全な状態で異常終了した時用に、すでにあるエントリは無視するinitを作りたい</li><li>キャッシュを元に計算をさぼるinitを実装したい <ul><li>この時、ファイルサイズも持っておく方がいいかも？</li></ul></li></ul><h2 id="キャッシュを使ったinitの仕様" tabindex="-1"><a class="header-anchor" href="#キャッシュを使ったinitの仕様"><span>キャッシュを使ったinitの仕様</span></a></h2><p>.uitの下にcachepath.txtというファイルがあったら、その中身の指すディレクトリの.uitをキャッシュとして使う。 さらに二行目があったら、それをlookup時のprefixとして使う。 ようするにキャッシュ先のサブディレクトリに対応させる為。 最初と最後のスラッシュは無し。</p><p>これらの条件を満たす時、initの時のキャッシュの計算としてキャッシュがヒットすればそのハッシュ値を使う事にする。</p><p>キャッシュにヒットさせるかどうかは将来的にはファイル名とサイズと日付にしたいが、今はサイズ情報は持ってない。 まずはパスと日付が一致しているケースをヒットとしよう。</p><h3 id="プレフィクスの扱い" tabindex="-1"><a class="header-anchor" href="#プレフィクスの扱い"><span>プレフィクスの扱い</span></a></h3><p>initの作業をする時、子供をinitして親にingestは出来るが、親で作業して子供にする事は出来ない。</p><p>initの作業は、究極的には一番下のディレクトリで行う事が出来るので、同じサブツリーを含むrepo同士であれば、 プレフィクスさえ指定出来ればいつでも一致する階層でinitの作業をする事は可能と思うので、 まずはプレフィクスを追加するだけで取り除く機能はつけない。</p><p>いつでもルックアップ先のキャッシュ側の方がツリーが深いという前提になるが、init作業を下で行う事はいつでも出来るので、この前提はいつでも満たせる（ただし作業がかったるいケースは存在するかもしれない）</p><h2 id="_2022-02-03-時点の雑感" tabindex="-1"><a class="header-anchor" href="#_2022-02-03-時点の雑感"><span>2022-02-03 時点の雑感</span></a></h2><p>今日、最初の目標であった64GBのmicroSDの全データを管理下に置く、という事が実現出来たヽ(´ー｀)ノ</p><p>64GBのmicroSD、いろいろ試行錯誤をしていたら二重エントリとかが出来てしまったので、とりあえず.uitディレクトリを全部削除してやりなおした。 将来的には二重エントリとかも処理出来るようにしたいが、 今はそれよりも正常系がちゃんと動くようにしたいので。</p><p>以前64GBを管理下に置くのは一日作業というか一日かけて終わらない感じだったが、 今回はだいぶいろいろ整備されてきたので、複数シェル開いて並行で作業していくとそんな大変でも無い（時間は掛かるが手間はそこまででも無い）。</p><p>全データでいちいちこの処理をやり直すのは辛いので、何らかの方法で同じようなデータでは結果を持っていく方法が欲しいなぁ。 最初はメタデータを丸コピーして不整合な一覧を表示する、というのを考えたのだが、ハッシュの計算（のためのread）に時間がかかるのだとすれば、 この計算をキャッシュ的なものから持ってくるようにするだけでもいいかもなぁ。 タイムスタンプとパスが既知のものでハッシュ値があればそれを使う、的な。</p><p>不整合を知る方法は欲しい気もするけれど、削除されるケースを考えると面倒なんだよな。 それよりは既存のデータを使ってinitが出来れば、あとはinitした後に手作業で変更された部分を後から一覧で取得出来れば良くて、 このケースでは削除はあまり考えなくても… 待てよ？そもそもキャッシュから高速にinit出来るのなら、既存の.uitをrenameしてこれを元にまたinitし直せば不整合はすべて無くせるんじゃないか。 実装も簡単だし安全そうだし、こっちの方が良さそうだな。</p><p>速度次第ではあるが、ファイルのバックアップの都度一回走らせるくらいだから、多少長いくらいなら待てるかもしれない。</p><p>USBハードディスク側ではそのうち不整合のチェックは欲しくなる気もするが、まずは必要になるまでやらないの精神でいってみよう。</p><p>次は複数のmicroSDのデータを管理する為の機能を追加すれば、Google Play Musicからサルベージしたデータのうち必要なものだけスマホに移す、と、壊れたギャラノの本体データをバックアップして端末を廃棄するという、とりあえず解決したい問題が解決出来るはず。 もう2日くらい開発すればそこまでイケるかな。 ただちょっと燃え尽きてきたので少し違う事をやって寝かせたい。</p><p>ある程度自分が使いたいと思ってるユースケースで使ってみて固まってきたら、第三者向けの解説を作るかなぁ。 だいぶ複雑になってしまったので、自分以外に理解出来るような説明が書けるかは分からないが。</p><h2 id="hashのディレクトリが意外と大きい" tabindex="-1"><a class="header-anchor" href="#hashのディレクトリが意外と大きい"><span>hashのディレクトリが意外と大きい</span></a></h2><p>6.8GBの音楽のディレクトリを管理したら、管理領域が281MBになった。うーん、少ないような大きいような。 Macにコピーするだけで8MBになる。exFAT効率悪すぎだなぁ。ほとんど空のフォルダが640KB取られてしまうんだな。 うーん。</p><p>ちなみにzipで圧縮すると837KB。扱いが面倒になるが、これは必要かなぁ。</p><p>ちなみにファイルの数は仕方ないとして、フォルダの数が多い問題は複数の子ディレクトリにバラバラに.uitがある状態だったから、というのはある。最後に統合する気だったのだが、今あるのを一通り統合してみよう。</p><p>統合してみた。884MB。うーん、ちょっと大きいか。zipにすると2MB。うーん、この小ささは魅力的だが、扱いが面倒になるのがなぁ。</p><p><a href="https://docs.microsoft.com/en-us/dotnet/standard/io/how-to-compress-and-extract-files" target="_blank" rel="noopener noreferrer">How to: Compress and extract files - Microsoft Docs</a></p><p>まぁ扱いの面倒さはそんな変わらないか？ ググってたらもうちょっと使いやすい事を意図したライブラリもあるらしい。</p><p><a href="https://github.com/haf/DotNetZip.Semverd" target="_blank" rel="noopener noreferrer">haf/DotNetZip.Semverd</a></p><p>こっちで良いかもしれない。</p><p>さらに少し調査。統合した.uitでは一番大きいディレクトリがf6で、5.3MB。zipすると14KB。 これならlinkとか変更する都度全具書き直しでいいか。</p><h3 id="hashをzipにした" tabindex="-1"><a class="header-anchor" href="#hashをzipにした"><span>hashをzipにした</span></a></h3><p>これまでの34/とかのディレクトリを34.zipに変更した。 先頭二文字なので256ファイルくらい出来る感じ。</p><p>zipの中にはhashの二文字切った.txtが入っている。</p><p>これで880MBくらいだった管理領域が32MBくらいになった。 dirsの方が70MBくらい使っているのでこちらの方が大きくなったが、こちらはバックアップ対象のディレクトリツリーをディレクトリだけほぼマップしたものなので、まぁいいかなぁ（ファイル数では無くディレクトリ数に一致するので）</p><p>追記: 61GBのデータを管理して、最終的にdirs 127MB、hash 32MBの合計159MBに落ち着いた。 ハッシュはデータが増えてもあまり変わらない。dirsはディレクトリ数が増えると大きくなっていくが、 61GBのデータで159MBくらい使う、なら許容範囲かなぁ。</p><h2 id="存在しないエントリだけ追加するinitが欲しい" tabindex="-1"><a class="header-anchor" href="#存在しないエントリだけ追加するinitが欲しい"><span>存在しないエントリだけ追加するinitが欲しい</span></a></h2><p>大量にディレクトリのある所でinit -rしてしまい、途中まで行った所でこけた時に、どこまで終わったのか良くわからない。 こういう時に、dir.txtが存在して正しそうだったら次に進むinitが欲しい。</p><h2 id="_2022-01-31-現時点の雑感" tabindex="-1"><a class="header-anchor" href="#_2022-01-31-現時点の雑感"><span>2022-01-31 現時点の雑感</span></a></h2><p>64GBのmicro SDをこれで管理することが出来そうな所までは来た。 幾つか遅い所もあるけれど、スケーラビリティ的には実用レベルなことが保証されたと思う。</p><p>最初の段階では.uit下のメタ情報をちゃんと構築して操作するのが大切で、 その為に必要な最低限の操作を幾つか用意してやれば、あとはシェルスクリプトとかで使い始められるという手応えを感じている。 しかもそういう風に使いやすいようにコマンドを揃えていく方が実際のオペレーションでも使いやすくて便利だよなぁ。</p><p>これまでもなるべくfsxから叩いて試しながら仕様を考えてきたが、やはりコマンドラインから叩けるように整備して大きなデータに対して使えるようになったのは大きな前進で、 そうなる前に実装したimportなどは仕様が複雑な割には当面は使わないので、 これを先に実装したのは間違いだったなぁ、とか思っている。</p><p>あと2〜3日作業をすればとりあえずやりたい作業ができるようになると思うので、そこまでは頑張りたい。 結構凄い物が作れそうで、ちょっとワクワクしている。</p><h2 id="壊れたファイルシステムの対応" tabindex="-1"><a class="header-anchor" href="#壊れたファイルシステムの対応"><span>壊れたファイルシステムの対応</span></a></h2><p><code>uit init -r</code>すると、EnumerateFilesではエントリがあるが実体に触れない壊れファイルがあると、initをする手段が無い。 こういうケースでも触れるファイルだけを管理したい。 こういうケースは手動で良いが、手動でやる為に幾つか足りない機能がある。</p><ul><li>どこまでinitが終了したのかを知る方法（dirs下をlsすれば分かるが、uitのサブコマンドで知る方法が欲しい）</li><li>ファイル一つをaddする方法</li></ul><p>ということで実装してみた。</p><h3 id="lsm-管理されているファイルとディレクトリの一覧を表示" tabindex="-1"><a class="header-anchor" href="#lsm-管理されているファイルとディレクトリの一覧を表示"><span>lsm 管理されているファイルとディレクトリの一覧を表示</span></a></h3><p><code>uit lsm .</code>で現在のディレクトリのうち、dirs下にエントリのあるファイルの一覧と、dirs下に対応するディレクトリのあるディレクトリ一覧が表示される。 直下のものしか表示しない。</p><p><code>uit lsm -d .</code>でディレクトリのみ表示。</p><h3 id="add-管理されていない子ファイルを追加" tabindex="-1"><a class="header-anchor" href="#add-管理されていない子ファイルを追加"><span>add 管理されていない子ファイルを追加</span></a></h3><p>ディレクトリに壊れエントリがある時などに、それらをスキップして特定のファイルだけ足したい、ということがある。 そこで一つだけ追加する、というaddというサブコマンドを実装。</p><h3 id="何もmanageしないemptyでのinitを実装" tabindex="-1"><a class="header-anchor" href="#何もmanageしないemptyでのinitを実装"><span>何もmanageしないemptyでのinitを実装</span></a></h3><p>initは直下のファイルを全部manageしようとして、だいたいはこれでいいのだけれど、 中に壊れファイルがあるとこの挙動は困る。</p><p>ということで、<code>uit init -e</code>でemptyな状態でinitする、というのを実装した。</p><h3 id="壊れファイルシステムについてのメモ" tabindex="-1"><a class="header-anchor" href="#壊れファイルシステムについてのメモ"><span>壊れファイルシステムについてのメモ</span></a></h3><p>自分の用途的に、microSDが壊れると新しいmicroSDを買ってきてそれをコピーして使う訳だが、 壊れ具合によっては前の前のmicroSDからコピーした後に必要なファイルだけ幾つか手でコピーしていたりして、 内容が微妙に違う風になってしまっていて、これらを管理したいのだよな。 特定のmicroSDからサルベージしそこなっているファイルとかを探したい。</p><p>その為にはこわれたmicroSDに対して使いたいが、壊れたmicroSDは壊れているのでいろいろ変なことが起こる。 そういうおかしなことが起きても全部やり直しじゃなくて、その少し前からやり直せるようにしておかないといけない。</p><p>中途半端な状態というのは扱いが難しいので、小さな完全な状態を組み合わせて大きな完全な状態を作るように作る必要があるよなぁ。</p><h3 id="壊れたファイルシステムで良く使うスクリプト片" tabindex="-1"><a class="header-anchor" href="#壊れたファイルシステムで良く使うスクリプト片"><span>壊れたファイルシステムで良く使うスクリプト片</span></a></h3><p><strong>ファイルだけをadd</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">$ ls -p | grep -v / | sed &#39;s/^/uit add &quot;/;s/$/&quot;/&#39; &gt; temp.sh</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>ディレクトリだけをinitatとingest</strong></p><p>空白とかなければ以下。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">$ ls -1d */ | sed &#39;s/^/uit initat /&#39; &gt; temp1.sh</span>
<span class="line">$ ls -1d */ | sed &#39;s/^/uit ingest /&#39; &gt; temp2.sh</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>空白があると以下。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">$ ls -1d */ | sed &#39;s/^/uit initat &quot;/;s/$/&quot;/&#39; &gt; temp1.sh</span>
<span class="line">$ ls -1d */ | sed &#39;s/^/uit ingest &quot;/;s/$/&quot;/&#39; &gt; temp2.sh</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="initを下から順番に手動で出来るようにする-ingestの実装" tabindex="-1"><a class="header-anchor" href="#initを下から順番に手動で出来るようにする-ingestの実装"><span>initを下から順番に手動で出来るようにする（ingestの実装）</span></a></h2><p>2022-01-30 現在、いざ使ってみようとすると、 どうもバカでかいファイルツリーに一気にinit処理を走らせる感じになってしまい、 動く気がしなくて気後れてしまう。</p><p>一番最初にやらなくてはいけないuit initが面倒そうなのがとりあえず使ってみるのを妨げている。 管理したいファイルが膨大だが、突然それに対して全部一気に動く処理をするのは、動かすのも大変だしバグがあった時に解決するのも面倒過ぎる。</p><p>どうなっているといいのかな、と思うに、サブフォルダから順番にinitしていって、子供のinit済みのフォルダをマージしていくようになってれば良いよなぁ。 そういうことが出来るような機能が欲しい。 当初はimportで代用すればいいかと思っていたが、どうもオペレーションが面倒で使う気が起こらない。</p><p>現状のinitは、再帰的に一気に全部作ろうとしてしまうが、 こういうのは大規模なものに対してはトラブルに弱い。 一つ一つの処理は数十秒で終わって失敗しても痛くないような単位であるべきだよな。 そっちの方がデバッグも開発もしやすいし、使う時も楽だ。 自動で動きすぎずに途中途中で手動が入る方が良い。</p><p>ハッシュを計算しない、単にファイルだけ作るuit initがあって、そのあとにinit済みの子フォルダを指定してマージしていきたい。 子供の.uitフォルダを無くして親の庇護下に入る処理を作ろう。</p><h3 id="子供のrepoを取り込むコマンド名-ingestに決定" tabindex="-1"><a class="header-anchor" href="#子供のrepoを取り込むコマンド名-ingestに決定"><span>子供のrepoを取り込むコマンド名（ingestに決定）</span></a></h3><p>なんて名前がいいだろう？</p><ul><li>編入する transfer</li><li>統合する integrate</li><li>会員にする、傘下に置く、加盟する affilicate</li><li>組み込む incorporate</li><li>(口から体内に）取り込む ingest</li></ul><p>affiliateが意味的には近いが、incorporateの方が馴染みがあっていいかな。underとかもいい気がするが、これだとマージする感じが無いんだよなぁ。</p><p>merge child repoみたいなのが正しいんだよな。でもmcとかは絶対忘れるよなぁ。</p><p>includeとかtakeとかでもいいのだが、これだと子供の.uitが無くなる感じが出てないよなぁ。</p><p>eatとかingestとかがいいかもしれない。子供の.uitが無くなる感じもする。eatは何が起こるのかがちょっと直感的じゃないからingestにするかな。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">$ uit ing child/folder</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>うん、いい気がする。</p><h3 id="再帰的でないinitを作る" tabindex="-1"><a class="header-anchor" href="#再帰的でないinitを作る"><span>再帰的でないinitを作る</span></a></h3><p>initがすべて再帰的なせいでインクリメンタルに試せない。 だから現在のフォルダだけのinitを作る。</p><p>むしろ再帰的な方を別名にしたいな。initRecursiveにしよう。コマンドライン的にはフラグを指定するだけだろうから、ソース内での関数名がやぼったくてもいいだろう。</p><h3 id="ingestに必要な処理を考える" tabindex="-1"><a class="header-anchor" href="#ingestに必要な処理を考える"><span>ingestに必要な処理を考える</span></a></h3><ul><li>mbinfo listのマージ</li><li>dirs下のマージ</li><li>子供の.uitフォルダを消す</li></ul><p>最後はいいので前２つを考える。</p><p><strong>mbinfo listのマージ</strong></p><ol><li>子供のmbinfo listの、パスを差し替えたものを作る</li><li>親のmbinfo listとマージして保存する</li></ol><p>この二段階か。</p><p><strong>dirs下のマージ</strong></p><ol><li>親ディレクトリのdirs下に対応するディレクトリを掘る</li><li>dir.txtを親のdirs下に移動</li></ol><p>dir.txtは完全に同じものでいいんだな。</p><p>書き出してみるとそんな難しくないな。</p><p>実装してみた。良さそう。</p>`,102)])])}const d=a(s,[["render",p]]),h=JSON.parse('{"path":"/uit.html","title":"","lang":"en-US","frontmatter":{},"git":{"updatedTime":1644452907000,"contributors":[{"name":"Kazuma Arino","username":"","email":"hogeika2@gmail.com","commits":4}],"changelog":[{"hash":"5d5c4db6c8c9486fad244ed5b3484a811c041453","time":1644452907000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"bb4c84e331565a36f9a7c50bbce33f82db47553e","time":1643874659000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"55e118c019dc437135f2052b6d677d617dd73c8b","time":1643551868000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"d033d37db515df8a4aa4b602a7c0dd1a1183667a","time":1643511028000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"}]},"filePathRelative":"uit.md"}');export{d as comp,h as data};
