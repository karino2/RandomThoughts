プログラミングの心理学。ワインバーグの本の中ではそこまで話題には上がらないが、自分はこの本が一番好きだった気がする。

<iframe sandbox="allow-popups allow-scripts allow-modals allow-forms allow-same-origin" style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="//rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS2=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=karino203-22&language=ja_JP&o=9&p=8&l=as4&m=amazon&f=ifr&ref=as_ss_li_til&asins=B00F0FQ8C4&linkId=1ff1c4771b311c063970f3d55129f4bf"></iframe>

[他人に向けての発信 - なーんだ、ただの水たまりじゃないか](https://karino2.github.io/2022/11/10/write_for_others.html)でも書いたように、何かプログラム関連のエッセイを書くのがいいんじゃないかという気がしているのもあり、
プログラム関連のエッセイを読みたい気分だったので、昔読んで悪くなかったプログラミングの心理学を再購入。
一応改訂されているらしい。
この本、タイトルで心理学を期待すると全然違うので騙されたとなるので注意。
心理学は学問的な意味では無くてプログラミングにまつわる人間の心理に焦点を当ててる、くらいのニュアンス。

## 1章と2章を読んだ雑感

たとえば現代のプログラムの良くあるシチュエーションとの違い、みたいな事は、全部の章にまたがる話題と思うけれど、
読んで思った都度メモを残しておきたいと思うと、全部読んでまとめるのは少し書きづらいし読む側も何を指しているのか分かりにくいと思う。

という事でこの本の感想は適当に何章かまとめて、その範囲内で思う事を書く、という事をやっていきたい。
他の章で同じ事を考えて重複するような雑感のメモが出来る事もあると思うけれど、書きやすさ優先という事で。

### プログラムを読むとか適応性を考えるとかの話と、対象としている世界の特殊さ

ほとんどのプログラマはプログラムを読まない、という話をしているが、これはそうでも無いように思う。
少なくとも皆がプログラムを読んでいると主張はする程度には一般的な事では無いか。

適応性の事は全然考えられない、というが、現代的にプログラムの良し悪しを語る時に、変更の容易さを議論しない人も居ないように思う。
なんかこの辺はプログラマーのプログラム観の、時代による変化をかんじる。

全体的に、仕様書があってプログラマは集団でそれを満たすものを作る、というような世界観があって、
昔のメーカーとかのプログラム環境を前提としている部分を大きくかんじる。
それは現代の大多数のプログラム環境をあまり代表してないようにかんじるな。

「みんなが思っているプログラムはこうだけど、実際はそれは間違っているよ」という体裁になっているのだけれど、
「みんなが思っているプログラム」は、アルゴリズムがプログラムの中心であって、その良し悪しで評価されて、
一度書かれて完成されたらもう変更されないようなもの、という感じに思う。
これは現代の多くの初心者プログラマが誤って思ってしまう世界観では無いように思う。
どちらかというとアルゴリズムが中心になるようなプログラムは、今や多くの初心者プログラマにとっては高度な専門性の高い領域で、
最初に間違ってそれが普通と思う何かでは無いんじゃないか。
とりあえずwebのプログラムを入門しましょう、で、そういう誤りを持つ余地は無いように思う。

ドキュメントは変更を容易にする為にあるのでちゃんとある方が適応性が高い的な事を言っているが、
これは暗黙のうちに一度プログラムが完成するとしばらくはいじられず、
そのあとしばらくたっていじる必要性が出てきた時にドキュメントを見ながら直すと直しやすいですよね、
という世界観を前提としている気がする。
でも現代的な観点では、ドキュメントがいろいろ書かれてしまうとそのメンテが面倒で変更が大変になる事は良くある。
それは変更が、この時思っていたよりもさらに日常的なシチュエーションが増えてきているからじゃないか。
少なくともこの、ドキュメントがあるおかげで変更が簡単でいいですね、
というシチュエーションは、現代の多くのプログラマにとっての「普通の環境」とは程遠いように思う。
昔のメーカーのプログラムって感じだよなぁ。

良く出てくる例にコンパイラの開発があるが、コンパイラはユーザーもプログラマであるという点で、
ソフトウェア開発においてとても特殊な領域と思う。
この当時はコンパイラに限らず、コンピュータのユーザーはある程度特別な人だったのでこの例はそれなりに一般的だったのだろうなぁ、と推測は出来るけれど、
現代の多くのプログラウの典型的な話を代表しては居ないよなぁ。

### 車の部品のプログラムの例に見る、優れた技術エッセイの書き方

良いプログラムとは何かという話で、
プログラムは不正確に早く動いても意味は無くて、正しく動く方が大切だ、という解説がある。
これ自体は当たり前の話だけれど、この説明が良い。

自動車の組み立てに必要な部品を調べるプログラムの話がある。
エアコンの有無でスペースが変わるのでリアシートの内装が変わる、みたいな制約条件があるので、
お互いの条件が複雑に絡み合っていて分岐が数千もあってテストもほとんど不可能で、
典型的な入力をしてもタイヤが8個とか出てくるような状況だった、と始まる。

それを予め定義されたテーブルとマッチングするだけのように変更したら２日くらいで動くものが出来た、
という感じに続く。

元の主張の、正しく動かないが巧妙で早いプログラムには意味が無い（何もしなくて良ければ誰でも実行時間は0に出来る）、
という主張それ自体は、さほど面白さも無いと思う。
けれどこの本のこの部分は読んでいてもなかなか楽しく、また結構印象的でもある。
自分は20年以上前に読んだのに今でも覚えているエピソードだった（この本だったかは覚えてなかったが）。

ここの説明が面白いのは、結構具体的なプログラムの話をする所にあると思う。
しかも細かくプログラムの話をしている訳では無い。聞き手がある程度自分の経験と照らし合わせて言っている事を推し量る必要がある感じの記述になっている。
しかもこの元のプログラムを開発していたプログラマのすごく人間的な（ダメな）反応が具体的な所が、
また印象深く感じさせている所に思う。

プログラムのエッセイでは、適度に具体的なプログラムの例は結構大切だよなぁ。

また、無駄な設定の細かさも面白さを増している気がする。入った時にはデスマになっている記述、
プロジェクトから少し離れて飛行機に乗っている時に思いついた、的な記述、
会社はこのプロジェクトを不可能だからと中止しようとしている所で慌てて戻ってプレゼンしたり反発にあったりする記述。
こういう小話が面白さを増している。
お話としてこういう要素を追加しておくのは大切なんだろうな。

### プログラムは普通すぐ捨てられるのか、変更され続けて使われ続けるのか

適応性の所でプログラムは使われずに捨てられてしまうような事もあるが、
プロのプログラマーが開発したプログラムのほとんどは一定期間存続し、その間にプログラムが修正される、と言っている。
そして特定のアーキテクチャ向けにコンパイラを最適化した所、命令セットが追加されて対応が難しくなったというような例が出ている。

でもこの、一度つくったプログラムは基本的にはある程度長く使われて、CPUアーキテクチャの変更などに晒されるという前提はどのくらい正しいだろうか？
例えば今Android向けに書いたアプリが、Androidの次の世代の何かに移植出来る必要性は、ほとんどのケースでは無いように思う。
それよりもずっと早く、多くのプログラムはディスコンになっている。

例えば自分が趣味で書いたアプリの半分くらいは、「作ってみたら思ったよりもいまいちだったので結局誰も使わなかった」として捨てられているように思う。
趣味なのでより捨てやすいという側面はあるけれど、仕事だってうまく行かないで捨てられているものは多い。
例えば仕事で書いた機械学習のレコメンドなどは、その次くらいには新世代のモデルが導入されて捨てられたと思う。
たぶん2年ちょっととかで書き直されている。
その間に大きな変更はたぶんされていない。

仕事で書いて、そのあと連綿と使われ続けたプログラムもいくつかはある。
けれどそちらが多数派か？と言われると、そうでは無いように思う。
作ってみて少し使われたがそのあといろいろな事情で捨てられたプログラムの方が多いんじゃないかなぁ。
そしてそれは失敗でも無い。
作って使ってみる事で得られるものがあり、それは次に活かされている事も多い。
だが、プログラムはやがて変更されるものなのでドキュメントとかコメントをたくさん書いておけ、みたいな主張は、
自分の過去の仕事を振り返るとあまり当たってないように思う。

CPUアーキテクチャに依存した最適化をしがちだが、すぐアーキテクチャは変わるよ、というのは、
いかにも黎明期の洞察だよなぁ。

### 良いプログラムとはなにか？

パフォーマンスとかでプログラムの良し悪しは決められないぞ、こんなにそれ以外に考える事がある、と言って4つの項目を挙げている。

1. 仕様にそった（大部分は満たした）動きをちゃんとするか
2. スケジュールに間に合っているか
3. 適応性（変更が容易か）
4. (実行）効率

これらのどこにも、自分が重視している「プログラマ人生においてこれをやった！と思えるような社会に対するインパクト」とか、
「時代を分けるような競争に勝つかどうか」みたいな要素が入っていないのは、
プログラマというものに対する捉え方に大きな差があるようにも思う。
例えば現在自分がプログラムにおいて成功とか失敗を考えるのは、だいたいが[[40代のプログラマ目標]]に書いた事に沿ったものになるが、
そこには上記の4つはせいぜい2くらいしか入っていない（それもスケジュールというよりはtime to market的な何かだ）。
これはプログラマというものの変化という気もするが、一方で80年代のBill Gやジョブズだって自分と同じような価値観であったと思われるので、
別に時代という問題でも無く、ワインバーグの考えるプログラマの偏りという気もする。

章末にマネージャーに対する質問とプログラマに対する質問というのがあり、この中身はマネージャーが作るものをプログラマに伝えてプログラマがそれを作るかのような前提がある気がするが、これは現代においては多数派では無かろうし、
自分が重視するプログラムにおいて大切な事が入らない特殊な分野という気がする。
プログラムにおける様々なトレードオフを決めるのがマネージャーという前提になっているが、
昨今はその辺を非プログラマがやるのはむしろ例外だよなぁ。

「振り返って」のあとから足した項目に経済的要因について言及があるが、これの優先度もびっくりするほど低くて驚く。
プログラムにおいて経済的な成功はめちゃくちゃ重要だと思うんだが、それが良いプログラムの条件に入っていない。
一方で一切の金銭的な儲けを気にせずに行うプログラムもあるので、これが入らない場合もあると思う。
ただそれは上記の4つの条件にも全て言えるよな。
仕様にそっているかはユーザーにとって良いかよりは大切じゃない事の方が多かろう。
適応性は結局勝負に負けて撤退するなら必要では無い。
効率が必要でない事が多いのはすでに本書の時点でも言及されている。
ではここに経済的成功を含めない理由はあるのだろうか？

自分にとって良いプログラムは、やはり決戦において勝利するプログラムだよなぁ。

例えば上の4つの条件を順番に見ていくと、
正しく動いて使っていて良いと思える品質であるがゆえに競争に勝つ事はあるだろう。
勝負のタイミングでちゃんと市場に出せているがゆえに勝てる事もあるだろう。
変更が容易な事で重要なチャンスをつかめるという事もあるだろう。
効率がユーザーの心を掴む事で勝負に勝てる事もあるだろう。
それぞれが重要な要素たりえる場合はあると思う。

だがこの本はそういう大切さみたいなものは会社とかマネージャーが考えてそれに沿っているかどうかがプログラマの責務として重要であるという前提に立っている気がする。
だがそれでは、冴えない会社で冴えないマネージャーと仕事をしている場合は、プログラマとして良いけれど結果としてはしょぼい、ということも成立してしまう。
良いプログラムに、そうした条件が内側に無いのはおかしいんじゃないか。
プログラマが人生の重要な時間を使ってする仕事が、お前のプログラム人生においてそれで良いのか、みたいな視点が欠けているように思える。
それはプログラマにとって会社の成功やマネージャーの望み通りかよりもずっとずっと重要な事に思える。
それらが会社とかマネージャーの方向性と一致するのも大切とは思うけれど、それらが上に来る事は無かろう。

そういう点で、この本のイメージするプログラマは非常にサラリーマン的だよなぁ。
でも現代のプログラマにおいて、良いプログラムというのが例えばマーケットシェアを取れるプログラムとか、
そういう視点は必須だと思うし、それらのうちかなり多くの部分をプログラマが負っている、というのは、
そう珍しい少数派の考えという訳でも無い気はする。

### 例の古さと現代に通じるかどうか

効率や効果がカード読み取り式を前提としているが現代でも本質的には同じである、的な事が書いてあって、これは同意する部分としない部分がある。
現代においても通じる教訓は存在するが、
一方で時代の違いで通じないものや、この時代には重要ではなかったが現代では重要になった事も多くあるように思う。
やはり現代のプログラミングについて議論をしたいなら、現代の例の方が良いのでは無いか。

一方で読み物としては現代でも面白く読める。面白く読む為の文章という点では現代でも良いお手本になりうると思う。

## 3章、プログラミングをどのように研究するか

プログラミングという活動をどう研究するかという話が始まるが、あまり関心が湧かない。
有意義な結果が得られるのかどうかが分からないのにやり方を議論しているからという気がする。
何を研究するかが不明なまま研究の手法を議論してもあまり面白くない。

プログラミングしているのを観察したり実験したりする事について語っているのだが、
こうした事の先に理解を深めてくれる何かがあるのだろうかね？

### 一般化する事の危うさ

「プログラマーが平均で作業時間の3分の2を、１人での作業ではなくほかの人たちとの作業に費やしているとしたら（実際そうなのだが）」という記述があるのだが、自分の現状は9割以上を１人の作業に費やしている。
平均を見てプログラムという全体を語るのはあまり良いやり方では無いような気がする。

プログラムは同質な部分を見るよりも、多様な部分を見る方が実態に迫れるのでは無いか。

### 時代による変化の早さと研究の意義

プログラミングの研究というのはまだまだ歴史も浅く、先の長い話のように思う。
一方で80年代と現代のプログラミングの違いは、この本を読む範囲でもかなりあるように思える。

科学的に研究をする意義というのは積み重ねていく事で他の方法では得られないような深い理解に到達出来るという事だと思うのだが、
こう変化する分野でもそれは正しいのだろうか？
例えば単にプログラマがそれぞれ思う事を書き綴るよりも本当に深い理解に到達するのだろうか？

一方で2010年と2022年の違いは、そこまで大きく無いような気もする。
2010年くらいからの研究ならその先に積み重ねていけるのだろうか？
でも2010年くらいの頃は2005年くらいからあまり変化が無くなった的な事を言っていた気もするが、
今思うと2005年と今では結構違う気がする。

長期間積み重ねが必要な科学的手法というのと相性が悪い可能性もあるよなぁ。
実際80年代から40年間くらい人類はこの手の研究を積み重ねてきた訳だが、
何かそれらの研究が自分の仕事に役に立っているかというとあまり役に立っている事は思いつかない。
たまに面白い話やへーって話はあるのだけれど、何かただプログラマーとして日々を過ごす以上の理解に到達しているのかは怪しい気もする。

### 章末の振り返ってで自分の印象と同じような事を言っている

やはり学術的プロセスの有効性は良く分からないよなぁ。無いとも言えないがあるとも言えない。
なのでそれを検討すべきかも良く分からない。
実験はいろいろ行われたが、実際のプログラミングにそれほど有益な影響を与えているような気もしない。

やはりこの章は今の視点から考えると微妙だよなぁ、と思う。
こうした手法でやっていこうと当時思っていたんだろうな、とは思うし、実際やったんだろうが、
それほどうまく行かなかった試みの予定を長々と説明された文章を読んだだけという気がする。

上手く行かなかったという事について考えるのは有意義に思う。むしろそこについての考えを聞きたいよなぁ。
これが25年前の本である欠点か。