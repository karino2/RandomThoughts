import{_ as a,c as n,a as s,o as i}from"./app-CTYZxEMR.js";const l={};function r(t,e){return i(),n("div",null,[...e[0]||(e[0]=[s(`<p><a href="./技術的なメモ.html">技術的なメモ</a>、<a href="./CG.html">CG</a></p><p>私（karino2）が仕事で作っているGPU用フィルタ記述言語。</p><ul><li>公式ページ <a href="https://modernfilterlanguageforgpu.org/" target="_blank" rel="noopener noreferrer">MFG - Modern Filter-language for GPU / MFG Studio</a></li><li>ドキュメントトップ <a href="https://github.com/karino2/MFG/blob/main/docs/ja/README.md" target="_blank" rel="noopener noreferrer">MFG/docs/ja/README.md at main · karino2/MFG</a></li><li><a href="https://modernfilterlanguageforgpu.org/ja/contest/" target="_blank" rel="noopener noreferrer">MFG - Modern Filter-language for GPU / 学生GPUプログラミングコンテスト</a></li><li><a href="https://www.youtube.com/playlist?list=PL3J_mLcl4YCf1AHEjZO4PjdaIexukpb6e" target="_blank" rel="noopener noreferrer">MFGプログラムシリーズ - YouTube</a></li></ul><h2 id="グレースケール" tabindex="-1"><a class="header-anchor" href="#グレースケール"><span>グレースケール</span></a></h2><p>良く使うのでコードを書いておく。</p><p><a href="./【書籍】PrinciplesOfDigitalImageProcessing.html">【書籍】PrinciplesOfDigitalImageProcessing</a>の一冊目のp202とp203に以下のweightが載っている。</p><ul><li><code>(0.299, 0.587, 0.114)</code> テレビの信号処理で提案されて業界で良く使われているもの</li><li><code>(0.215, 0.7154, 0.072)</code> ITU-BT.709の推奨、この本の他の場所ではこれを使っている</li></ul><p>どちらもlineariseしたあとに使う。</p><p>また、lineariseする前に使う近似weightがVol 2.のp111, 6.17に書いてあって、それは</p><ul><li><code>(0.309, 0.609, 0.082)</code></li></ul><p>となっている。</p><p>また、<a href="./【書籍】OpenGL4ShadingLanguageCook.html">【書籍】OpenGL4ShadingLanguageCook</a>のサンプルコードでは、例えばEdge Detectionのフィルタのluminanceは以下のベクトルをかけて求めている。</p><ul><li><code>(0.2126, 0.7152, 0.0722)</code></li></ul><p>これはITU-BT.709の推奨と似た数値なのでlineariseしないと駄目な気がするが、ホスト側でしているのかな？</p><h3 id="mfgのとりあえずのコード" tabindex="-1"><a class="header-anchor" href="#mfgのとりあえずのコード"><span>MFGのとりあえずのコード</span></a></h3><p>とりあえずは以下のようにするのが一番良いか。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">  let gray = to_xyza(input_u8(x, y)).y</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>動作確認としては以下。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">def result_u8 |x, y| {</span>
<span class="line">  let gray = to_xyza(input_u8(x, y)).y</span>
<span class="line">  [gray, gray, gray, 1.0] |&gt; to_u8color(...)</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上記の式で計算するのもそんなに大変ではないが、とりあえずこれを評価して駄目だった事はない。</p><h2 id="ハッシュ" tabindex="-1"><a class="header-anchor" href="#ハッシュ"><span>ハッシュ</span></a></h2><p>この論文が素晴らしく良くまとまっている。</p><p><a href="https://jcgt.org/published/0009/03/02/" target="_blank" rel="noopener noreferrer">Hash Functions for GPU Rendering (JCGT)</a></p><p>2次元で使うならPCGかな。<code>hash(x + hash(y))</code> とするのがperlinノイズで使っていた手法とか。 MFGはハットが累乗に使われているのでxorが関数なのに注意。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">fn hash |i: i32| {</span>
<span class="line">  let state = u32(i) * 747796405u + 2891336453u</span>
<span class="line">  let word = xor((state &gt;&gt; ((state &gt;&gt; 28u) + 4u)), state) * 277803737u</span>
<span class="line">  i32(xor((word &gt;&gt; 22u), word))</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">fn hash_xy |x:i32, y:i32| {</span>
<span class="line">  hash(x + hash(y))</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ちなみにuint32を0.0〜1.0にマップするには以下が良いとか。（関数の外はi32で統一、という方針に従い、i32で渡してu32にキャストして計算している）</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">fn map_to_f32 |uval: i32| {</span>
<span class="line">  let inv = 1.0 / 4294967295.0</span>
<span class="line">  f32(u32(uval))*inv</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">let tmp2 = map_to_f32(0xf0ffffff)</span>
<span class="line">@print_expr(tmp2)</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27)])])}const p=a(l,[["render",r]]),c=JSON.parse('{"path":"/MFG.html","title":"","lang":"en-US","frontmatter":{},"git":{"updatedTime":1757210739000,"contributors":[{"name":"Kazuma Arino","username":"","email":"hogeika2@gmail.com","commits":5}],"changelog":[{"hash":"99dee3a2cb274a6bf1efcb0c0fb726d1c678c93d","time":1757210739000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"0645a56b7443f5198f1b9e1d469dfdb825c102c8","time":1755691536000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"1d609d0cb38053dc0b2b0adfd6348c1123289a29","time":1755671014000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"94f99c0ae707c26fcc9901cad26412709b770ffe","time":1752131965000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"},{"hash":"c04463871d774ab69783b20033b7cd9492a70663","time":1752127539000,"email":"hogeika2@gmail.com","author":"Kazuma Arino","message":"update"}]},"filePathRelative":"MFG.md"}');export{p as comp,c as data};
