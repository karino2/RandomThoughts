- [æŠ€è¡“çš„ãªãƒ¡ãƒ¢](%E6%8A%80%E8%A1%93%E7%9A%84%E3%81%AA%E3%83%A1%E3%83%A2)
- [ãã®ã†ã¡ã‚„ã‚ŠãŸã„äº‹](%E3%81%9D%E3%81%AE%E3%81%86%E3%81%A1%E3%82%84%E3%82%8A%E3%81%9F%E3%81%84%E4%BA%8B)
- [ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ã‚’æ›¸ããŸã‚ã®è¨€èª](%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%84%E3%83%BC%E3%83%AB%E3%82%92%E6%9B%B8%E3%81%8F%E3%81%9F%E3%82%81%E3%81%AE%E8%A8%80%E8%AA%9E)

[FSharp](FSharp)ã£ã½ã„è¦‹ãŸç›®ã§[Go](Go)ã¨ã—ã¦å‹•ãè¨€èªã‚’ä½œã‚ŠãŸã„ãªãã€ã¨æ€ã„ã€Folangã¨åä»˜ã‘ã¦é–‹ç™ºã‚’ã—ã¦ã„ã‚‹ã€‚

## ãƒ¬ãƒã‚¸ãƒˆãƒª

[karino2/folang: Funcitonal language transpiler to golang.](https://github.com/karino2/folang/tree/main)

## é–‹ç™ºå‹•æ©Ÿ

dotnetã¯ã‚„ã£ã±ã‚Šã‹ã£ãŸã‚‹ã•ãŒã‚ã‚‹ã®ã§ã€runtimeã‚„ãƒ‡ãƒ—ãƒ­ã‚¤ã¯[Go](Go)ãŒè‰¯ã„ã¨æ€ã†ã€‚
ã§ã‚‚è¨€èªã¯[FSharp](FSharp)ã¿ãŸã„ãªã®ãŒå¥½ããªã®ã§ã€ãªã‚“ã‹ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«ã§ã©ã†ã«ã‹ãªã‚‰ã‚“ã‹ãªï¼Ÿ
å®Ÿç”¨ã«ã¯ãªã‚‰ãªãã¦ã‚‚goã®ãŠéŠã³ã¨ã—ã¦çµæ§‹ã‚„ã£ã¦ã¿ãŸã„æ°—ã‚‚ã™ã‚‹ã€‚

ã¨ã‚Šã‚ãˆãšç°¡å˜ãªã‚·ãƒ³ãƒœãƒ«ã®ãƒ„ãƒªãƒ¼ã‹ã‚‰goã®ã‚½ãƒ¼ã‚¹ç”Ÿæˆã™ã‚‹ã®ã‚’ä½œã£ã¦ã€ãã‚Œã‚’ç™ºå±•ã•ã›ã¦ã„ã£ã¦ãã‚Œã£ã½ã„ã‚‚ã®ã«å‡ºæ¥ãªã„ã‹ã—ã‚‰ï¼Ÿ
ã‚»ãƒ«ãƒ•ãƒ›ã‚¹ãƒˆå‡ºæ¥ã‚‹æ„Ÿã˜ã«å‡ºæ¥ãŸã‚‰ã¡ã¾ã¡ã¾æ™‚é–“ã‚’ã‹ã‘ã¦é€²ã‚ã¦ã„ã‘ãã†ãªæ°—ã‚‚ã™ã‚‹ãŒã€‚

fsharpã‚’ç§»æ¤ã—ãŸã„ã®ã§ã¯ãªãã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ çš„ã«ã¯ãªã‚‹ã¹ãgoãã®ã¾ã¾ã«ã—ãŸã„ã€‚ãƒ—ãƒ©ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡ã§å‹æƒ…å ±ãã‚‰ã„ã¯è¿½åŠ ã§æŒã£ã¦ã‚‚ã„ã„ã‹ã‚‚ã—ã‚Œãªã„ãŒã€‚
ã¨ã„ã†äº‹ã§è¨€èªçš„ã«ã¯å…¨ãæ–°ã—ã„è¨€èªã«ãªã‚‹ã ã‚ã†ã€‚

## é–¢é€£ãƒªãƒ³ã‚¯

å‚è€ƒã«ãªã‚Šãã†ãªãƒªãƒ³ã‚¯ã‚’è²¼ã£ã¦ãŠãã€‚

**golangé–¢é€£**

- [example/gotypes at master Â· golang/example](https://github.com/golang/example/tree/master/gotypes) go ã®type checker
  - [types package - go/types - Go Packages](https://pkg.go.dev/go/types)
- [elliotchance/pie: ğŸ• Enjoy a slice! A utility library for dealing with slices and maps that focuses on type safety and performance.](https://github.com/elliotchance/pie) mapã¨ã‹ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
   - [pie/v1 at master Â· elliotchance/pie](https://github.com/elliotchance/pie/tree/master/v1) v1ã¯ã‚³ãƒ¼ãƒ‰ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã—ã¦ã„ã‚‹ã‚‰ã—ãã€ã‚³ãƒ¡ãƒ³ãƒˆã¨ã‹ã§ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‹ã—ã¦ã„ã‚‹ã®ã§ã‚³ãƒ¼ãƒ‰çš„ã«ã¯ä¼¼ãŸã‚‚ã®ãŒä½¿ãˆã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚

**golangã«ã‚ˆã‚‹è¨€èªå‡¦ç†ç³»**

- [kztomita/golisp: Goã«ã‚ˆã‚‹LISPå®Ÿè£…](https://github.com/kztomita/golisp/tree/master) IRã®ãƒ„ãƒªãƒ¼ã¨ã‹ã‚’Goã§ã©ã‚“ãªæ„Ÿã˜ã§æ›¸ãã®ã‹ã®å‚è€ƒã«
   - [Goè¨€èªã§ã¤ãã‚‹ã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ - O'Reilly Japan](https://www.oreilly.co.jp/books/9784873118222/) ã“ã‚“ãªæœ¬ãŒã‚ã‚‹ã‚‰ã—ã„ã€‚ã¾ãã‚ã¾ã‚Šèª­ã‚€å¿…è¦ã‚‚æ„Ÿã˜ãªã„ãŒã€‚
   - [bradford-hamilton/monkey-lang: Currently extending the Monkey programming language designed in the books "Writing An Interpreter In Go" and "Writing a Compiler in Go"](https://github.com/bradford-hamilton/monkey-lang/tree/master) ä¸Šè¨˜ã®æœ¬ã§å‡ºã¦ãã‚‹monkeyè¨€èªã‚’æ‹¡å¼µã—ã¦ã„ã‚‹ã‚‚ã®ã‚‰ã—ã„ã€‚
- [google/starlark-go: Starlark in Go: the Starlark configuration language, implemented in Go](https://github.com/google/starlark-go) æ‰‹æœ¬ã¨ã—ã¦ã¯starlarkã¨ã‹ã©ã†ã ã‚ã†ã€‚
- [rhysd/gocaml: :camel: Statically typed functional programming language implementation with Go and LLVM](https://github.com/rhysd/gocaml) è¨€èªçš„ã«ã¯camlãŒä¼¼ã¦ã‚‹ã‚ˆãªï¼ˆå½“ãŸã‚Šå‰ï¼‰
- [google/grumpy: Grumpy is a Python to Go source code transcompiler and runtime.](https://github.com/google/grumpy) pythonã®golangã¸ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ©ã€‚ã“ã‚“ãªã®ã‚ã£ãŸã®ã‹ï¼ï¼Ÿ

**å‚è€ƒã«ãªã‚Šãã†ãªé–¢æ•°å‹è¨€èªç³»**

- [Pattern Matching / Destructuring - ReScript Language Manual](https://rescript-lang.org/docs/manual/v10.0.0/pattern-matching-destructuring) ReScriptã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯JSã®ä¾‹ãŒå‡ºã¦ã„ã¦ã‹ãªã‚Šå‚è€ƒã«ãªã‚‹ã€‚ãªãœã‹æœ€æ–°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯JSã®ã‚³ãƒ¼ãƒ‰ãŒãƒã‚°ã£ã¦ã‚‹ã®ã§v10ã®ãƒªãƒ³ã‚¯ã‚’è²¼ã£ã¦ãŠãã€‚
    - [Overview Â· Reason](https://reasonml.github.io/docs/en/overview) ReasonMLã€JSã¨ã®interoperabilityã‚’é‡è¦–ã—ã¦ã„ã‚‹ã®ã§ã“ã‚Œã¯ã“ã‚Œã§å‚è€ƒã«ãªã‚‹ã€‚ï¼ˆè¿½è¨˜ï¼šReScriptã®æ–¹ãŒãƒ¡ãƒ³ãƒ†ã•ã‚Œã¦ãã†ï¼‰
- [oden/doc/compiler-overview.md at master Â· oden-lang/oden](https://github.com/oden-lang/oden/blob/master/doc/compiler-overview.md) Haskellã§æ›¸ã‹ã‚ŒãŸä¼¼ãŸã‚ˆã†ãªã‚³ãƒ³ã‚»ãƒ—ãƒˆã®ã‚‚ã®ã€‚ã‹ãªã‚Šé ‘å¼µã£ã¦ã„ã‚‹ãŒé€”ä¸­ã§é–‹ç™ºãŒæ­¢ã¾ã£ã¦ã„ã¦æ®‹å¿µã€‚
- [Explore this site - F# for fun and profit](https://fsharpforfunandprofit.com/site-contents/) fun and profitã¯ã¨ã‚Šã‚ãˆãšã“ã“ã‹ã‚‰ã€‚
- [Golang Â· fable-compiler/Fable Â· Discussion #3346](https://github.com/fable-compiler/Fable/discussions/3346) fableã®golangãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é€”ä¸­ã¾ã§ã€‚
- [Borgo Programming Language](https://borgo-lang.github.io/) Rustã£ã½ã„è¨€èªã‚’golangã«ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã‚‰ã—ã„
   - [borgo/std/core/core.brg at 3b9f01578941fb00ed93756e2fadc009feb50128 Â· borgo-lang/borgo](https://github.com/borgo-lang/borgo/blob/3b9f01578941fb00ed93756e2fadc009feb50128/std/core/core.brg#L125) brogoã§ã®Tupleã¨ã‹ã€‚å‚è€ƒã«ãªã‚Šãã†ã€‚
   - [borgo/importer/importer.go at 3b9f01578941fb00ed93756e2fadc009feb50128 Â· borgo-lang/borgo](https://github.com/borgo-lang/borgo/blob/3b9f01578941fb00ed93756e2fadc009feb50128/importer/importer.go) Importerã€‚ã“ã†ã„ã†ã®è‡ªåˆ†ã‚‚ä½œã‚‰ãªã„ã¨ãªãã€‚
      - [Borgo Programming Language](https://borgo-lang.github.io/#package-definitions)ã€€å‹æƒ…å ±ãƒ•ã‚¡ã‚¤ãƒ«ãŒã©ã†ãªã£ã¦ã„ã‚‹ã‹ã€‚

**ãã®ä»–**

- [Parsing expressions by precedence climbing - Eli Bendersky's website](https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing)

## ä»•æ§˜æ¤œè¨

### æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«

F# ã¯ãƒ€ãƒ–ãƒ«ã‚¯ã‚ªãƒ¼ãƒˆï¼“ã¤ãŒã‚ã‚‹ãŒã€golangã¯ãƒãƒƒã‚¯ã‚¯ã‚ªãƒ¼ãƒˆãªã‚“ã ã‚ˆãªãã€‚
ãã—ã¦interpolationã¯æ¬²ã—ã„ã€‚

[Interpolated strings - F# - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/interpolated-strings)

ã¨ã‚Šã‚ãˆãšãƒãƒƒã‚¯ã‚¯ã‚ªãƒ¼ãƒˆã¨ãƒ‰ãƒ«å§‹ã¾ã‚Šã‚’å®Ÿè£…ã™ã‚‹ã‹ãªã€‚


```
let a = `This is
Multiline
string`

let b = $"String {a} interpolation"

let c = $`This
is
also {a}
interpolation. {{}} for brace pair.`
```

ã“ã®ï¼’ã¤ãŒã‚ã‚Œã°ååˆ†ã‹ã€‚

### Unionã®generics

Golangã®interfaceã£ã¦genericsä½¿ãˆã‚‹ã®ã‹ãªï¼Ÿã¨èª¿ã¹ã¦ã‚‚è‰¯ãåˆ†ã‹ã‚‰ãªã‹ã£ãŸãŒã€chatGPTã«èã„ãŸã‚‰ã‚³ãƒ¼ãƒ‰å‡ºã—ã¦ãã‚Œã¦å‹•ã„ãŸã€‚

```golang
package main

import "fmt"

// å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ T ã‚’æŒã¤ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
type Printer[T any] interface {
	Print(value T)
}

// int å‹ã® Printer å®Ÿè£…
type IntPrinter struct{}

func (p IntPrinter) Print(value int) {
	fmt.Println("Printing int:", value)
}

// string å‹ã® Printer å®Ÿè£…
type StringPrinter struct{}

func (p StringPrinter) Print(value string) {
	fmt.Println("Printing string:", value)
}

func main() {
	var intPrinter Printer[int] = IntPrinter{}
	intPrinter.Print(42)

	var stringPrinter Printer[string] = StringPrinter{}
	stringPrinter.Print("Hello, World!")
}
```

ã“ã‚ŒãŒå‹•ããªã‚‰ãã‚Œã»ã©é›£ã—ã„äº‹ã¯ç„¡ã„ã‹ãªï¼Ÿ

Optionalã®å®Ÿè£…ã¨ã‹ã£ã¦ã©ã£ã‹ã«ã‚ã‚‹ã®ã‹ãªã€ã¨ã‚°ã‚°ã£ã¦ä»¥ä¸‹ã‚’è¦‹ã¤ã‘ã‚‹ã€‚

[Generic Go Optionals Â· Preslav Rachev](https://preslav.me/2021/11/18/generic-golang-optionals/)

ãªã‚“ã‹ãƒ¬ã‚³ãƒ¼ãƒ‰ã¨Unionã®Genericså¯¾å¿œã‚‚å‡ºæ¥ãã†ã ãªã€‚

ä»¥ä¸‹ã¿ãŸã„ãªã®ã‚’ä½œã‚ŠãŸã„ã€‚

```
type Result<T> =
| Success of T
| Failure of string
```

ã“ã‚Œã¯Goã®ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã¯ã€ä»¥ä¸‹ã§è‰¯ã•ãã†ã‹ã€‚

```golang
type Result[T any] interface {
   Result_Union()
}

func (Result_Success[T]) Result_Union(){}
func (Result_Failure[T]) Result_Union(){}

type Result_Success[T any] struct {
  Value T
}

type Result_Failure[T any] struct {
  Value string
}

func New_Result_Success[T any](v T) Result[T] { return Result_Success[T]{v} }
func New_Result_Failure[T any](v string) Result[T] { return Result_Failure[T]{v} }
```

å‹•ä½œã¯ç¢ºèªå‡ºæ¥ãŸã€‚

ã§ã‚‚Folangå´ã§ã®å‹æ¨è«–ã¯ç°¡å˜ã§ã¯ç„¡ã„ã‚ˆãªã€‚

[Understanding Parser Combinators - F# for fun and profit](https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/)

ã®ä»¥ä¸‹ã®ä¾‹ã‚’è¦‹ã‚‹ã¨

```fsharp
type ParseResult<'a> =
  | Success of 'a
  | Failure of string

let pchar (charToMatch,str) =
  if String.IsNullOrEmpty(str) then
    Failure "No more input"
  else
    let first = str.[0]
    if first = charToMatch then
      let remaining = str.[1..]
      Success (charToMatch,remaining)
    else
      let msg = sprintf "Expecting '%c'. Got '%c'" charToMatch first
      Failure msg
```

ã“ã®Failureã®æ–¹ã®type parameterã¯Successã®æ–¹ã§åˆã‚ã¦ç¢ºå®šã™ã‚‹è¨³ã§ã€‚ã„ã‚„ã€åˆ¥ã«å…¨éƒ¨ãƒãƒ©ãƒãƒ©ã«type variableã‚’æŒ¯ã£ã¦æ¨ç§»å¾‹ã§unifyã™ã‚Œã°ã„ã„ã‹ã€‚

æœ¬å®¶ã®Resultå‹ã‚‚è²¼ã£ã¦ãŠãã€‚

- [Result<'T, 'TError> (FSharp.Core) - FSharp.Core](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-fsharpresult-2.html)
- [Result (FSharp.Core) - FSharp.Core](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-resultmodule.html)
- [Results - F# - Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/results)

### å€¤ãŒç„¡ã„ã‚±ãƒ¼ã‚¹ãŒã“ã‚Œã§ã¯ã†ã¾ã†è¡Œã‹ãªã„

å®Ÿè£…ã‚’ã—ã¦ã¿ã‚ˆã†ã¨ã—ãŸæ‰€ã€å€¤ãŒç„¡ã„ã‚±ãƒ¼ã‚¹ãŒã†ã¾ãè¡Œã‹ãªã„ã€‚[folang/docs/specs/union_ja.md at main Â· karino2/folang](https://github.com/karino2/folang/blob/main/docs/specs/union_ja.md)

ã‚‚ã¨ã‚‚ã¨ä»¥ä¸‹ã®ã‚ˆã†ãªUnionã«ã¯

```fsharp
type AorB =
  | A
  | B
```

ä»¥ä¸‹ã®ã‚ˆã†ãªGoã®ã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã¦ã„ãŸã€‚

```golang
var New_AorB_A AorB = AorB_A{}
```

ã ãŒã€ã“ã‚Œã§ã¯TãŒæŒ‡å®šå‡ºæ¥ãªã„ã€‚
ã“ã†ã„ã†å¤‰æ•°ã¯ä½œã‚Œãªã„ã€‚

```golang
var New_AorB_A AorB[T] = AorB_A[T}{}
```

å€¤ãŒç„¡ã„ã‚±ãƒ¼ã‚¹ã‚‚é–¢æ•°ã«ã™ã‚‹ã—ã‹ç„¡ã„ã‹ãªãã€‚ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚Œã°ãŠãŠã‚€ã­ã„ã„ã‹ã€‚

```golang
func New_AorB_A[T any]() AorB[T] { return AorB_A[T]{} }
```

Folangã¨ã—ã¦ã¯å½“ç„¶æ˜ç¤ºçš„ã«specifyã™ã‚‹ã—ã‹ç„¡ã„ãŒã€

```fsharp
AorB_A<int> ()
```

F# ã§ã¯ã©ã†ãªã£ã¦ã„ã‚‹ã‚“ã ã£ã‘ï¼Ÿ

```
> type AorB<'t> =
- | A
- | B of 't
-
- ;;
type AorB<'t> =
  | A
  | B of 't

> A ;;
val it: AorB<'a>

> B 123 ;;
val it: AorB<int> = B 123
```

ã†ãƒ¼ã‚€ã€Aã¯genericså‹ã®å¤‰æ•°ã«ãªã‚‹ã®ã‹ã€‚ã“ã‚Œã¯ãŸã¶ã‚“golangã§ã¯å®Ÿç¾å‡ºæ¥ãªã„ãªã€‚ã©ã†ã™ã‚‹ã®ãŒã„ã„ã‚“ã ã‚ã†ï¼Ÿ

ReScriptã§ã‚‚ã‚„ã¯ã‚Šç•°ãªã‚‹å‹ã®å¼•æ•°ã«åŒã˜å¤‰æ•°ãŒä½¿ãˆã‚‹ãªã€‚

```rescript

type result<'a> =
  | Ok('a)
  | Failure
  | Other


module App = {
  let iToS = (i) => {
    switch(i) {
      | Ok(arg) => Int.toString(arg)
      | Failure => "int fail"
      | Other => "int other"
    }
  }
  
  let sToS = (s) => {
    switch(s) {
      | Ok(arg) => arg
      | Failure => "s fail"
      | Other => "s other"
    }
  }
    
  let make = (cond) => {
    let f = Failure
    let o = Other
    let a = if cond { Ok(123) } else { f }
    let b = if cond { Ok("abc") } else { f }
    iToS(a) ++ sToS(b) ++ iToS(o) ++ sToS(o)
  }
}
```

å¤‰æ•°ã®å‚ç…§ã®æ‰€ã§å‹ãŒæ±ºã¾ã‚Šã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¨ã—ã¦ã¯åˆ¥ã«åŒã˜å€¤ã‚’å…¥ã‚Œã¦ãŠã„ã¦ã‚­ãƒ£ã‚¹ãƒˆã§ã‚‚ã™ã‚Œã°è‰¯ã„ã¨ã„ã†æ°—ã¯ã™ã‚‹ã€‚
ã“ã®ã‚±ãƒ¼ã‚¹ã ã‘ã¯å¤‰æ•°ã®å®šç¾©ã§ã¯ç„¡ãã¦å‚ç…§ã§å‹ãŒæ±ºã¾ã‚‹æ°—ãŒã™ã‚‹ãªã€‚

### Folangã§ã¯ã‚¿ã‚¤ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚‹æ™‚ã¯é–¢æ•°ã«ã™ã‚‹

Golangã«å­˜åœ¨ã—ãªã„æ¦‚å¿µã‚’ã‚ã¾ã‚Šå…¥ã‚Œã™ãã‚‹ã®ã‚‚ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ©ã¨ã—ã¦è‰¯ããªã„ãªã€ã¨æ€ã„ç›´ã—ã€ä»¥ä¸‹ã®ã‚±ãƒ¼ã‚¹ã§ã¯ã€

```
type AorB<T> =
 | A
 | B of T
```

Aã‚’ä½œã‚‹å ´åˆã¯`()`ã®å¼•æ•°ãŒã‚ã‚‹ã¨ã™ã‚‹ã€‚

```
let a = A<int> ()
```

inferenceã§ç¢ºå®šã™ã‚‹ãªã‚‰intã¯ç„¡ã—ã§ã‚‚è‰¯ã„ãŒã€ã¨ã«ã‹ãé–¢æ•°ã‚³ãƒ¼ãƒ«ã ã¨ã™ã‚‹ã€‚
ã“ã‚Œã ã¨ä¸€åº¦ç¢ºå®šã—ãŸå¤‰æ•°ãŒé•ã†å‹ã«ãªã‚‹äº‹ã¯å‡ºæ¥ãªã„ãŒã€ãã‚ŒãŒä»•æ§˜ã¨ã™ã‚‹ã€‚

ã‚¿ã‚¤ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒç„¡ã„æ™‚ã¯å¤‰æ•°ã«ãªã‚‹ã®ã§ä¸€è²«æ€§ã¯ç„¡ã„ã€‚å…¨éƒ¨é–¢æ•°ã«ã™ã¹ãã ã£ãŸã¨æ€ã†ã‘ã‚Œã©ã€ä»Šã‹ã‚‰ç›´ã™æ°—ã‚‚èµ·ã“ã‚‰ãªã„ã®ã§ã€
genericsã ã‘ã®ç‰¹åˆ¥æ‰±ã„ã¨ã™ã‚‹ã€‚

## é–‹ç™ºæ—¥è¨˜

ã‚„ã£ãŸäº‹ã‚’æ›¸ãå ´æ‰€ãŒæ¬²ã—ãã¦ã¨ã‚Šã‚ãˆãšã“ã“ã«ç½®ã„ã¦ãŠãã€‚

[Folangéå»ãƒ­ã‚°](Folang%E9%81%8E%E5%8E%BB%E3%83%AD%E3%82%B0)



### ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°å®šç¾©å¯¾å¿œã€Unionã®genericså¯¾å¿œ 2025-03-02 (æ—¥)

Unionã®genericsã‚’å¯¾å¿œã™ã‚‹ã«ã‚ãŸã‚Šã€å†å¸°å‹ã®æ‰±ã„ãŒé›£ã—ããªã£ã¦ãã¦ã€lookupã‚’å¿…è¦ã«ãªã‚‹ã¾ã§é…ã‚‰ã›ã‚‹ã‚ˆã†ã«ç›´ã—ãŸããªã‚‹ã€‚
ã‘ã‚Œã©ã„ã¡ã„ã¡lookupã®è¾æ›¸ã‚’å…¨ã¦ã«æ¸¡ã™ã®ã¯å«Œï¼ˆå¤§å¤‰æ›´ã ã‹ã‚‰ï¼‰ãªã®ã§ã€ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«å¯¾å¿œã—ã‚ˆã†ã€ã¨æ€ã„ç«‹ã¤ã€‚
ã“ã‚Œã¾ã§ã‚‚Goã®å´ã§å®šç¾©ã—ã¦é–¢æ•°ã§ãƒ©ãƒƒãƒ—ã™ã‚Œã°ä½¿ãˆãŸã‘ã‚Œã©ã€
åˆ¥ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«å¯¾å¿œã—ã¦ã‚‚è‰¯ã„ã§ã—ã‚‡ã†ã€‚

Golangã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¯ã€å³è¾ºãŒå®šæ•°ã˜ã‚ƒãªã„ã¨constã¯ä½¿ãˆãªã„ã®ã§ã€å…¨éƒ¨varã«ã™ã‚‹ã€‚

ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ä½¿ã£ã¦ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚„Unionã®æƒ…å ±ã‚’è¾æ›¸ã«å…¥ã‚Œã¦å¿…è¦ã«ãªã‚‹ã¾ã§lookupã‚’é…ã‚‰ã›ã‚‹ã“ã¨ã§recuriveå•é¡Œã‚’è§£æ±ºã—ã€
ãã‚Œã‚’ãƒ™ãƒ¼ã‚¹ã«Unionã®genericså¯¾å¿œã‚’ã™ã‚‹ã€‚
ãªã‚“ã¨ãªãå‹•ã„ã¦ã„ã‚‹é¢¨å‘³ã‹ï¼Ÿ