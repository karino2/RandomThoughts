{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked and modified from https://github.com/markdown-it/markdown-it-container/blob/master/index.mjs\n */\n\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type Renderer from \"markdown-it/lib/renderer.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { MarkdownItContainerOptions } from \"./options.js\";\n\nconst MIN_MARKER_NUM = 3;\n\nexport const container: PluginWithOptions<MarkdownItContainerOptions> = (\n  md,\n  options,\n) => {\n  if (typeof options !== \"object\" || !options.name) {\n    throw new Error(\"[@mdit/plugin-container]: 'name' option is required.\");\n  }\n\n  const {\n    name,\n    marker = \":\",\n    validate = (params: string): boolean =>\n      params.trim().split(\" \", 2)[0] === name,\n    openRender = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      _env: unknown,\n      slf: Renderer,\n    ): string => {\n      // add a class to the opening tag\n      tokens[index].attrJoin(\"class\", name);\n\n      return slf.renderToken(tokens, index, options);\n    },\n    closeRender = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      _env: unknown,\n      slf: Renderer,\n    ): string => slf.renderToken(tokens, index, options),\n  } = options;\n\n  const markerStart = marker[0];\n  const markerLength = marker.length;\n\n  const container: RuleBlock = (state, startLine, endLine, silent) => {\n    const currentLineStart = state.bMarks[startLine] + state.tShift[startLine];\n    const currentLineMax = state.eMarks[startLine];\n    const currentLineIndent = state.sCount[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (markerStart !== state.src[currentLineStart]) return false;\n\n    let pos = currentLineStart + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= currentLineMax) {\n      if (marker[(pos - currentLineStart) % markerLength] !== state.src[pos])\n        break;\n      pos++;\n    }\n\n    const markerCount = Math.floor((pos - currentLineStart) / markerLength);\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    pos -= (pos - currentLineStart) % markerLength;\n\n    const markup = marker.repeat(markerCount);\n    const params = state.src.slice(pos, currentLineMax);\n\n    if (!validate(params, markup)) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n      const nextLineMax = state.eMarks[nextLine];\n\n      if (\n        nextLineStart < nextLineMax &&\n        state.sCount[nextLine] < currentLineIndent\n      )\n        // non-empty line with negative indent should stop the list:\n        // - :::\n        //  test\n        break;\n\n      if (\n        // closing fence should be indented same as opening one\n        state.sCount[nextLine] === currentLineIndent &&\n        // match start\n        markerStart === state.src[nextLineStart]\n      ) {\n        // check rest of marker\n        for (pos = nextLineStart + 1; pos <= nextLineMax; pos++)\n          if (marker[(pos - nextLineStart) % markerLength] !== state.src[pos])\n            break;\n\n        // closing code fence must be at least as long as the opening one\n        if (Math.floor((pos - nextLineStart) / markerLength) >= markerCount) {\n          // make sure tail has spaces only\n          pos -= (pos - nextLineStart) % markerLength;\n          pos = state.skipSpaces(pos);\n\n          if (pos >= nextLineMax) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n\n    // @ts-expect-error: We are creating a new type called \"container\"\n    state.parentType = \"container\";\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    // this will update the block indent\n    state.blkIndent = currentLineIndent;\n\n    const openToken = state.push(`container_${name}_open`, \"div\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = params;\n    openToken.map = [startLine, nextLine];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    const closeToken = state.push(`container_${name}_close`, \"div\", -1);\n\n    closeToken.markup = markup;\n    closeToken.block = true;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", `container_${name}`, container, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n  md.renderer.rules[`container_${name}_open`] = openRender;\n  md.renderer.rules[`container_${name}_close`] = closeRender;\n};\n"],"names":["container","md","options","name","marker","validate","params","openRender","tokens","index","_env","slf","closeRender","markerStart","markerLength","state","startLine","endLine","silent","currentLineStart","currentLineMax","currentLineIndent","pos","markerCount","markup","nextLine","autoClosed","nextLineStart","nextLineMax","oldParent","oldLineMax","oldBlkIndent","openToken","closeToken"],"mappings":"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"}