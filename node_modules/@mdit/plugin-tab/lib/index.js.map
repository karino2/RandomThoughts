{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["import { escapeHtml } from \"@mdit/helper\";\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type Renderer from \"markdown-it/lib/renderer.mjs\";\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type {\n  MarkdownItTabData,\n  MarkdownItTabInfo,\n  MarkdownItTabOptions,\n} from \"./options.js\";\n\nconst MIN_MARKER_NUM = 3;\nconst TAB_MARKER = \"@tab\";\nconst ACTIVE_TAB_MARKER = TAB_MARKER + \":active\";\nconst TAB_MARKER_LENGTH = TAB_MARKER.length;\nconst ACTIVE_TAB_MARKER_LENGTH = ACTIVE_TAB_MARKER.length;\n\nconst checkTabMarker = (\n  state: StateBlock,\n  start: number,\n  max: number,\n): false | { isActive: boolean; pos: number } => {\n  /*\n   * Check out the first character quickly,\n   * this should filter out most of non-uml blocks\n   */\n  if (state.src.charCodeAt(start) !== 64 /* @ */) return false;\n\n  let pos = 1;\n\n  // Check out the rest of the marker string\n  for (; pos < ACTIVE_TAB_MARKER_LENGTH; pos++)\n    if (ACTIVE_TAB_MARKER.charCodeAt(pos) !== state.src.charCodeAt(start + pos))\n      break;\n\n  const isActive = pos === ACTIVE_TAB_MARKER_LENGTH;\n\n  if (!isActive && pos !== TAB_MARKER_LENGTH) return false;\n\n  const markerEnd = start + pos;\n  const infoStart = state.skipSpaces(markerEnd);\n\n  if (infoStart > markerEnd && infoStart < max)\n    return { isActive, pos: infoStart };\n\n  return false;\n};\n\nconst getTabRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    if (store.state !== name) return false;\n\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n    const indent = state.sCount[startLine];\n\n    const tabMatch = checkTabMarker(state, start, max);\n\n    if (tabMatch === false) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n\n      if (\n        // marker should be indented same as opening one\n        state.sCount[nextLine] === indent &&\n        // match start\n        state.src[nextLineStart] === \"@\"\n      ) {\n        if (checkTabMarker(state, nextLineStart, state.eMarks[nextLine])) {\n          // found!\n          autoClosed = true;\n          break;\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n\n    // @ts-expect-error: We are creating a new type called \"tab\"\n    state.parentType = `tab`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    // this will update the block indent\n    state.blkIndent = indent;\n\n    const openToken = state.push(`${name}_tab_open`, \"\", 1);\n\n    const infoStart = tabMatch.pos;\n    const infoEnd = state.skipSpacesBack(max, infoStart);\n\n    let pos = infoEnd;\n    let escapePos: number;\n\n    while (pos > infoStart) {\n      /*\n       * Found potential #, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      if (state.src.charCodeAt(pos) === 35 /* # */) {\n        escapePos = pos - 1;\n\n        while (state.src.charCodeAt(escapePos) === 92 /* \\ */) escapePos--;\n\n        // Even number of escapes, potential closing delimiter found\n        if ((pos - escapePos) % 2 === 1) break;\n      }\n\n      pos--;\n    }\n\n    let title;\n    let id = \"\";\n\n    const hasId = pos !== infoStart;\n\n    if (hasId) {\n      id = state.src.slice(state.skipSpaces(pos + 1), infoEnd);\n      title = state.src.slice(infoStart, state.skipSpacesBack(pos, infoStart));\n    } else {\n      title = state.src.slice(infoStart, infoEnd);\n    }\n\n    openToken.block = true;\n    openToken.markup = TAB_MARKER;\n    openToken.info = title;\n    openToken.meta = {\n      active: tabMatch.isActive,\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (id) openToken.meta.id = id;\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    state.md.block.tokenize(\n      state,\n      startLine + 1,\n      nextLine + (autoClosed ? 0 : 1),\n    );\n\n    const closeToken = state.push(`${name}_tab_close`, \"\", -1);\n\n    closeToken.block = true;\n    closeToken.markup = \"\";\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 0 : 1);\n\n    return true;\n  };\n\nconst getTabsRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n    const indent = state.sCount[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    if (state.src.charCodeAt(start) !== 58 /* : */) return false;\n\n    let pos = start + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= max) {\n      if (state.src.charCodeAt(pos) !== 58 /* : */) break;\n      pos++;\n    }\n\n    const markerCount = pos - start;\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    pos = state.skipSpaces(pos);\n\n    // check name is matched\n    for (let i = 0; i < name.length; i++) {\n      if (state.src.charCodeAt(pos) !== name.charCodeAt(i)) return false;\n      pos++;\n    }\n\n    let hasId = false;\n    let char: number;\n\n    while (pos !== max) {\n      char = state.src.charCodeAt(pos++);\n      if (char === 35 /* # */) {\n        hasId = true;\n        break;\n      }\n      if (!isSpace(char)) return false;\n    }\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n    let idStart = pos;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n      const nextLineMax = state.eMarks[nextLine];\n\n      if (nextLineStart < nextLineMax && state.sCount[nextLine] < indent)\n        // non-empty line with negative indent should stop the list:\n        // - :::\n        //  test\n        break;\n\n      if (\n        // closing fence should be indented same as opening one\n        state.sCount[nextLine] === indent &&\n        // match start\n        state.src.charCodeAt(nextLineStart) === 58 /* : */\n      ) {\n        // check rest of marker\n        for (pos = nextLineStart + 1; pos <= nextLineMax; pos++)\n          if (state.src.charCodeAt(pos) !== 58 /* : */) break;\n\n        // closing code fence must be at least as long as the opening one\n        if (pos - nextLineStart >= markerCount) {\n          // make sure tail has spaces only\n          pos = state.skipSpaces(pos);\n\n          if (pos >= nextLineMax) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n    const oldState = store.state;\n\n    // @ts-expect-error: We are creating a new type called \"${name}_tabs\"\n    state.parentType = `${name}_tabs`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    // this will update the block indent\n    state.blkIndent = indent;\n\n    const markup = \":\".repeat(markerCount);\n    let id = \"\";\n\n    if (hasId) {\n      idStart = state.skipSpaces(idStart);\n      const idEnd = state.skipSpacesBack(max, idStart);\n\n      if (idStart < idEnd) id = state.src.slice(idStart, idEnd);\n    }\n\n    const openToken = state.push(`${name}_tabs_open`, \"\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = name;\n    openToken.meta = { id };\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    store.state = name;\n\n    state.md.block.tokenize(\n      state,\n      startLine + 1,\n      nextLine - (autoClosed ? 1 : 0),\n    );\n\n    store.state = oldState;\n\n    const closeToken = state.push(`${name}_tabs_close`, \"\", -1);\n\n    closeToken.markup = markup;\n    closeToken.block = true;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\nconst getTabsDataGetter =\n  (name: string): ((tokens: Token[], index: number) => MarkdownItTabInfo) =>\n  (tokens, index) => {\n    const data: MarkdownItTabData[] = [];\n    let activeIndex = -1;\n    let isTabStart = false;\n    let nestingDepth = 0;\n\n    for (\n      // skip the current tabs_open token\n      let i = index + 1;\n      i < tokens.length;\n      i++\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const { block, meta, type, info } = tokens[i];\n\n      if (block) {\n        // record the nesting depth of tabs\n        if (type === `${name}_tabs_open`) {\n          nestingDepth++;\n          continue;\n        }\n\n        if (type === `${name}_tabs_close`) {\n          if (nestingDepth === 0) break;\n          nestingDepth--;\n          continue;\n        }\n\n        // if we are in a nesting tabs, skip processing\n        if (nestingDepth > 0) continue;\n\n        if (type === `${name}_tab_open`) {\n          isTabStart = true;\n\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          meta.index = data.length;\n          // tab is active\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          if (meta.active)\n            if (activeIndex === -1) activeIndex = data.length;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            else meta.active = false;\n\n          data.push({\n            title: info,\n            index: data.length,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            id: meta.id as string | undefined,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            isActive: meta.active as boolean,\n          });\n\n          continue;\n        }\n\n        if (type === `${name}_tab_close`) continue;\n\n        // hide contents before first tab\n        if (!isTabStart) {\n          tokens[i].type = `${name}_tabs_empty`;\n          tokens[i].hidden = true;\n        }\n      }\n    }\n\n    return {\n      active: activeIndex,\n      data: data,\n    };\n  };\n\nconst tabDataGetter = (tokens: Token[], index: number): MarkdownItTabData => {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const { info, meta } = tokens[index];\n\n  return {\n    title: info,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    index: meta.index as number,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    id: meta.id as string | undefined,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    isActive: meta.active as boolean,\n  };\n};\n\nconst store = { state: null };\n\nexport const tab: PluginWithOptions<MarkdownItTabOptions> = (md, options) => {\n  const {\n    name = \"tabs\",\n\n    openRender = (\n      info: MarkdownItTabInfo,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const { active, data } = info;\n      const token = tokens[index];\n\n      token.attrJoin(\"class\", `${name}-tabs-wrapper`);\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (token.meta.id) token.attrJoin(\"data-id\", token.meta.id as string);\n\n      const tabs = data.map(\n        ({ title, id }, index) =>\n          `<button type=\"button\" class=\"${name}-tab-button${\n            active === index ? \" active\" : \"\"\n          }\" data-tab=\"${index}\"${id ? ` data-id=\"${escapeHtml(id)}\"` : \"\"}${\n            active === index ? \" data-active\" : \"\"\n          }>${escapeHtml(md.renderInline(title))}</button>`,\n      );\n\n      return `\\\n<div${self.renderAttrs(token)}>\n  <div class=\"${name}-tabs-header\">\n    ${tabs.join(\"\\n    \")}\n  </div>\n  <div class=\"${name}-tabs-container\">\n`;\n    },\n\n    closeRender = (): string => `\\\n  </div>\n</div>\n`,\n\n    tabOpenRender = (\n      info: MarkdownItTabData,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const token = tokens[index];\n\n      token.attrJoin(\n        \"class\",\n        `${name}-tab-content${info.isActive ? \" active\" : \"\"}`,\n      );\n      token.attrSet(\"data-index\", info.index.toString());\n      if (info.id) token.attrSet(\"data-id\", info.id.toString());\n\n      if (info.isActive) token.attrJoin(\"data-active\", \"\");\n\n      return `\\\n<div${self.renderAttrs(tokens[index])}>\n`;\n    },\n\n    tabCloseRender = (): string => `\\\n</div>\n`,\n  } = options ?? {};\n\n  const tabsDataGetter = getTabsDataGetter(name);\n\n  md.block.ruler.before(\"fence\", `${name}_tabs`, getTabsRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.block.ruler.before(\"paragraph\", `${name}_tab`, getTabRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[`${name}_tabs_open`] = (\n    tokens,\n    index,\n    options,\n    env,\n    self,\n  ): string => {\n    const info = tabsDataGetter(tokens, index);\n\n    return openRender(info, tokens, index, options, env, self);\n  };\n\n  md.renderer.rules[`${name}_tabs_close`] = closeRender;\n\n  md.renderer.rules[`${name}_tab_open`] = (tokens, index, ...args): string => {\n    const data = tabDataGetter(tokens, index);\n\n    return tabOpenRender(data, tokens, index, ...args);\n  };\n\n  md.renderer.rules[`${name}_tab_close`] = tabCloseRender;\n};\n"],"names":["MIN_MARKER_NUM","TAB_MARKER","ACTIVE_TAB_MARKER","TAB_MARKER_LENGTH","ACTIVE_TAB_MARKER_LENGTH","checkTabMarker","state","start","max","pos","isActive","markerEnd","infoStart","getTabRule","name","store","startLine","endLine","silent","indent","tabMatch","nextLine","autoClosed","nextLineStart","oldParent","oldLineMax","oldBlkIndent","openToken","infoEnd","escapePos","title","id","closeToken","getTabsRule","markerCount","i","hasId","char","isSpace","idStart","nextLineMax","oldState","markup","idEnd","getTabsDataGetter","tokens","index","data","activeIndex","isTabStart","nestingDepth","block","meta","type","info","tabDataGetter","tab","md","options","openRender","_options","_env","self","active","token","tabs","escapeHtml","closeRender","tabOpenRender","tabCloseRender","tabsDataGetter","env","args"],"mappings":"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"}