{"version":3,"file":"browser.js","sources":["../../helper/lib/index.js","../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs","../src/plugin.ts"],"sourcesContent":["const l=e=>{const n=e.split(`\n`),p=n.reduce((r,c)=>{for(let t=0;t<c.length;t++)if(c[t]!==\" \"&&c[t]!==\"\t\")return Math.min(t,r);return r},1/0);return p<1/0?n.map(r=>r.slice(p)).join(`\n`):e},a=e=>e.replace(/&/gu,\"&amp;\").replace(/</gu,\"&lt;\").replace(/>/gu,\"&gt;\").replace(/\"/gu,\"&quot;\").replace(/'/gu,\"&#39;\"),g=e=>e.replace(/[-/\\\\^$*+?.()|[\\]{}]/g,\"\\\\$&\"),u=/\\r\\n?|\\n/g,s=/\\\\([ \\\\!\"#$%&'()*+,./:;<=>?@[\\]^_`{|}~-])/gu;export{u as NEWLINE_RE,s as UNESCAPE_RE,l as dedent,a as escapeHtml,g as escapeRegExp};\n//# sourceMappingURL=index.js.map\n","// Utilities\n//\n\nimport * as mdurl from 'mdurl'\nimport * as ucmicro from 'uc.micro'\nimport { decodeHTML } from 'entities'\n\nfunction _class (obj) { return Object.prototype.toString.call(obj) }\n\nfunction isString (obj) { return _class(obj) === '[object String]' }\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction has (object, key) {\n  return _hasOwnProperty.call(object, key)\n}\n\n// Merge objects\n//\nfunction assign (obj /* from1, from2, from3, ... */) {\n  const sources = Array.prototype.slice.call(arguments, 1)\n\n  sources.forEach(function (source) {\n    if (!source) { return }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object')\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key]\n    })\n  })\n\n  return obj\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt (src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1))\n}\n\nfunction isValidEntityCode (c) {\n  /* eslint no-bitwise:0 */\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false }\n  if (c === 0x0B) { return false }\n  if (c >= 0x0E && c <= 0x1F) { return false }\n  if (c >= 0x7F && c <= 0x9F) { return false }\n  // out of range\n  if (c > 0x10FFFF) { return false }\n  return true\n}\n\nfunction fromCodePoint (c) {\n  /* eslint no-bitwise:0 */\n  if (c > 0xffff) {\n    c -= 0x10000\n    const surrogate1 = 0xd800 + (c >> 10)\n    const surrogate2 = 0xdc00 + (c & 0x3ff)\n\n    return String.fromCharCode(surrogate1, surrogate2)\n  }\n  return String.fromCharCode(c)\n}\n\nconst UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g\nconst ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi\nconst UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi')\n\nconst DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i\n\nfunction replaceEntityPattern (match, name) {\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    const code = name[1].toLowerCase() === 'x'\n      ? parseInt(name.slice(2), 16)\n      : parseInt(name.slice(1), 10)\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code)\n    }\n\n    return match\n  }\n\n  const decoded = decodeHTML(match)\n  if (decoded !== match) {\n    return decoded\n  }\n\n  return match\n}\n\n/* function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n} */\n\nfunction unescapeMd (str) {\n  if (str.indexOf('\\\\') < 0) { return str }\n  return str.replace(UNESCAPE_MD_RE, '$1')\n}\n\nfunction unescapeAll (str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped }\n    return replaceEntityPattern(match, entity)\n  })\n}\n\nconst HTML_ESCAPE_TEST_RE = /[&<>\"]/\nconst HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g\nconst HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n}\n\nfunction replaceUnsafeChar (ch) {\n  return HTML_REPLACEMENTS[ch]\n}\n\nfunction escapeHtml (str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar)\n  }\n  return str\n}\n\nconst REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g\n\nfunction escapeRE (str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&')\n}\n\nfunction isSpace (code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true\n  }\n  return false\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace (code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true\n  }\n  return false\n}\n\n/* eslint-disable max-len */\n\n// Currently without astral characters support.\nfunction isPunctChar (ch) {\n  return ucmicro.P.test(ch) || ucmicro.S.test(ch)\n}\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct (ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true\n    default:\n      return false\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference (str) {\n  // Trim and collapse whitespace\n  //\n  str = str.trim().replace(/\\s+/g, ' ')\n\n  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug\n  // fixed in v12 (couldn't find any details).\n  //\n  // So treat this one as a special case\n  // (remove this when node v10 is no longer supported).\n  //\n  if ('ẞ'.toLowerCase() === 'Ṿ') {\n    str = str.replace(/ẞ/g, 'ß')\n  }\n\n  // .toLowerCase().toUpperCase() should get rid of all differences\n  // between letter variants.\n  //\n  // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently\n  // uppercased versions).\n  //\n  // Here's an example showing how it happens. Lets take greek letter omega:\n  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)\n  //\n  // Unicode entries:\n  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n  //\n  // Case-insensitive comparison should treat all of them as equivalent.\n  //\n  // But .toLowerCase() doesn't change ϑ (it's already lowercase),\n  // and .toUpperCase() doesn't change ϴ (already uppercase).\n  //\n  // Applying first lower then upper case normalizes any character:\n  // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n  //\n  // Note: this is equivalent to unicode case folding; unicode normalization\n  // is a different step that is not required here.\n  //\n  // Final result should be uppercased, because it's later stored in an object\n  // (this avoid a conflict with Object.prototype members,\n  // most notably, `__proto__`)\n  //\n  return str.toLowerCase().toUpperCase()\n}\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nconst lib = { mdurl, ucmicro }\n\nexport {\n  lib,\n  assign,\n  isString,\n  has,\n  unescapeMd,\n  unescapeAll,\n  isValidEntityCode,\n  fromCodePoint,\n  escapeHtml,\n  arrayReplaceAt,\n  isSpace,\n  isWhiteSpace,\n  isMdAsciiPunct,\n  isPunctChar,\n  escapeRE,\n  normalizeReference\n}\n","import { escapeHtml } from \"@mdit/helper\";\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type Renderer from \"markdown-it/lib/renderer.mjs\";\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type {\n  MarkdownItTabData,\n  MarkdownItTabInfo,\n  MarkdownItTabOptions,\n} from \"./options.js\";\n\nconst MIN_MARKER_NUM = 3;\nconst TAB_MARKER = \"@tab\";\nconst ACTIVE_TAB_MARKER = TAB_MARKER + \":active\";\nconst TAB_MARKER_LENGTH = TAB_MARKER.length;\nconst ACTIVE_TAB_MARKER_LENGTH = ACTIVE_TAB_MARKER.length;\n\nconst checkTabMarker = (\n  state: StateBlock,\n  start: number,\n  max: number,\n): false | { isActive: boolean; pos: number } => {\n  /*\n   * Check out the first character quickly,\n   * this should filter out most of non-uml blocks\n   */\n  if (state.src.charCodeAt(start) !== 64 /* @ */) return false;\n\n  let pos = 1;\n\n  // Check out the rest of the marker string\n  for (; pos < ACTIVE_TAB_MARKER_LENGTH; pos++)\n    if (ACTIVE_TAB_MARKER.charCodeAt(pos) !== state.src.charCodeAt(start + pos))\n      break;\n\n  const isActive = pos === ACTIVE_TAB_MARKER_LENGTH;\n\n  if (!isActive && pos !== TAB_MARKER_LENGTH) return false;\n\n  const markerEnd = start + pos;\n  const infoStart = state.skipSpaces(markerEnd);\n\n  if (infoStart > markerEnd && infoStart < max)\n    return { isActive, pos: infoStart };\n\n  return false;\n};\n\nconst getTabRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    if (store.state !== name) return false;\n\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n    const indent = state.sCount[startLine];\n\n    const tabMatch = checkTabMarker(state, start, max);\n\n    if (tabMatch === false) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n\n      if (\n        // marker should be indented same as opening one\n        state.sCount[nextLine] === indent &&\n        // match start\n        state.src[nextLineStart] === \"@\"\n      ) {\n        if (checkTabMarker(state, nextLineStart, state.eMarks[nextLine])) {\n          // found!\n          autoClosed = true;\n          break;\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n\n    // @ts-expect-error: We are creating a new type called \"tab\"\n    state.parentType = `tab`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    // this will update the block indent\n    state.blkIndent = indent;\n\n    const openToken = state.push(`${name}_tab_open`, \"\", 1);\n\n    const infoStart = tabMatch.pos;\n    const infoEnd = state.skipSpacesBack(max, infoStart);\n\n    let pos = infoEnd;\n    let escapePos: number;\n\n    while (pos > infoStart) {\n      /*\n       * Found potential #, look for escapes, pos will point to\n       * first non escape when complete\n       */\n      if (state.src.charCodeAt(pos) === 35 /* # */) {\n        escapePos = pos - 1;\n\n        while (state.src.charCodeAt(escapePos) === 92 /* \\ */) escapePos--;\n\n        // Even number of escapes, potential closing delimiter found\n        if ((pos - escapePos) % 2 === 1) break;\n      }\n\n      pos--;\n    }\n\n    let title;\n    let id = \"\";\n\n    const hasId = pos !== infoStart;\n\n    if (hasId) {\n      id = state.src.slice(state.skipSpaces(pos + 1), infoEnd);\n      title = state.src.slice(infoStart, state.skipSpacesBack(pos, infoStart));\n    } else {\n      title = state.src.slice(infoStart, infoEnd);\n    }\n\n    openToken.block = true;\n    openToken.markup = TAB_MARKER;\n    openToken.info = title;\n    openToken.meta = {\n      active: tabMatch.isActive,\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (id) openToken.meta.id = id;\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    state.md.block.tokenize(\n      state,\n      startLine + 1,\n      nextLine + (autoClosed ? 0 : 1),\n    );\n\n    const closeToken = state.push(`${name}_tab_close`, \"\", -1);\n\n    closeToken.block = true;\n    closeToken.markup = \"\";\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 0 : 1);\n\n    return true;\n  };\n\nconst getTabsRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n    const indent = state.sCount[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    if (state.src.charCodeAt(start) !== 58 /* : */) return false;\n\n    let pos = start + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= max) {\n      if (state.src.charCodeAt(pos) !== 58 /* : */) break;\n      pos++;\n    }\n\n    const markerCount = pos - start;\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    pos = state.skipSpaces(pos);\n\n    // check name is matched\n    for (let i = 0; i < name.length; i++) {\n      if (state.src.charCodeAt(pos) !== name.charCodeAt(i)) return false;\n      pos++;\n    }\n\n    let hasId = false;\n    let char: number;\n\n    while (pos !== max) {\n      char = state.src.charCodeAt(pos++);\n      if (char === 35 /* # */) {\n        hasId = true;\n        break;\n      }\n      if (!isSpace(char)) return false;\n    }\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n    let idStart = pos;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n      const nextLineMax = state.eMarks[nextLine];\n\n      if (nextLineStart < nextLineMax && state.sCount[nextLine] < indent)\n        // non-empty line with negative indent should stop the list:\n        // - :::\n        //  test\n        break;\n\n      if (\n        // closing fence should be indented same as opening one\n        state.sCount[nextLine] === indent &&\n        // match start\n        state.src.charCodeAt(nextLineStart) === 58 /* : */\n      ) {\n        // check rest of marker\n        for (pos = nextLineStart + 1; pos <= nextLineMax; pos++)\n          if (state.src.charCodeAt(pos) !== 58 /* : */) break;\n\n        // closing code fence must be at least as long as the opening one\n        if (pos - nextLineStart >= markerCount) {\n          // make sure tail has spaces only\n          pos = state.skipSpaces(pos);\n\n          if (pos >= nextLineMax) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n    const oldState = store.state;\n\n    // @ts-expect-error: We are creating a new type called \"${name}_tabs\"\n    state.parentType = `${name}_tabs`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    // this will update the block indent\n    state.blkIndent = indent;\n\n    const markup = \":\".repeat(markerCount);\n    let id = \"\";\n\n    if (hasId) {\n      idStart = state.skipSpaces(idStart);\n      const idEnd = state.skipSpacesBack(max, idStart);\n\n      if (idStart < idEnd) id = state.src.slice(idStart, idEnd);\n    }\n\n    const openToken = state.push(`${name}_tabs_open`, \"\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = name;\n    openToken.meta = { id };\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    store.state = name;\n\n    state.md.block.tokenize(\n      state,\n      startLine + 1,\n      nextLine - (autoClosed ? 1 : 0),\n    );\n\n    store.state = oldState;\n\n    const closeToken = state.push(`${name}_tabs_close`, \"\", -1);\n\n    closeToken.markup = markup;\n    closeToken.block = true;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\nconst getTabsDataGetter =\n  (name: string): ((tokens: Token[], index: number) => MarkdownItTabInfo) =>\n  (tokens, index) => {\n    const data: MarkdownItTabData[] = [];\n    let activeIndex = -1;\n    let isTabStart = false;\n    let nestingDepth = 0;\n\n    for (\n      // skip the current tabs_open token\n      let i = index + 1;\n      i < tokens.length;\n      i++\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const { block, meta, type, info } = tokens[i];\n\n      if (block) {\n        // record the nesting depth of tabs\n        if (type === `${name}_tabs_open`) {\n          nestingDepth++;\n          continue;\n        }\n\n        if (type === `${name}_tabs_close`) {\n          if (nestingDepth === 0) break;\n          nestingDepth--;\n          continue;\n        }\n\n        // if we are in a nesting tabs, skip processing\n        if (nestingDepth > 0) continue;\n\n        if (type === `${name}_tab_open`) {\n          isTabStart = true;\n\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          meta.index = data.length;\n          // tab is active\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          if (meta.active)\n            if (activeIndex === -1) activeIndex = data.length;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            else meta.active = false;\n\n          data.push({\n            title: info,\n            index: data.length,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            id: meta.id as string | undefined,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            isActive: meta.active as boolean,\n          });\n\n          continue;\n        }\n\n        if (type === `${name}_tab_close`) continue;\n\n        // hide contents before first tab\n        if (!isTabStart) {\n          tokens[i].type = `${name}_tabs_empty`;\n          tokens[i].hidden = true;\n        }\n      }\n    }\n\n    return {\n      active: activeIndex,\n      data: data,\n    };\n  };\n\nconst tabDataGetter = (tokens: Token[], index: number): MarkdownItTabData => {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const { info, meta } = tokens[index];\n\n  return {\n    title: info,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    index: meta.index as number,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    id: meta.id as string | undefined,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    isActive: meta.active as boolean,\n  };\n};\n\nconst store = { state: null };\n\nexport const tab: PluginWithOptions<MarkdownItTabOptions> = (md, options) => {\n  const {\n    name = \"tabs\",\n\n    openRender = (\n      info: MarkdownItTabInfo,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const { active, data } = info;\n      const token = tokens[index];\n\n      token.attrJoin(\"class\", `${name}-tabs-wrapper`);\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (token.meta.id) token.attrJoin(\"data-id\", token.meta.id as string);\n\n      const tabs = data.map(\n        ({ title, id }, index) =>\n          `<button type=\"button\" class=\"${name}-tab-button${\n            active === index ? \" active\" : \"\"\n          }\" data-tab=\"${index}\"${id ? ` data-id=\"${escapeHtml(id)}\"` : \"\"}${\n            active === index ? \" data-active\" : \"\"\n          }>${escapeHtml(md.renderInline(title))}</button>`,\n      );\n\n      return `\\\n<div${self.renderAttrs(token)}>\n  <div class=\"${name}-tabs-header\">\n    ${tabs.join(\"\\n    \")}\n  </div>\n  <div class=\"${name}-tabs-container\">\n`;\n    },\n\n    closeRender = (): string => `\\\n  </div>\n</div>\n`,\n\n    tabOpenRender = (\n      info: MarkdownItTabData,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const token = tokens[index];\n\n      token.attrJoin(\n        \"class\",\n        `${name}-tab-content${info.isActive ? \" active\" : \"\"}`,\n      );\n      token.attrSet(\"data-index\", info.index.toString());\n      if (info.id) token.attrSet(\"data-id\", info.id.toString());\n\n      if (info.isActive) token.attrJoin(\"data-active\", \"\");\n\n      return `\\\n<div${self.renderAttrs(tokens[index])}>\n`;\n    },\n\n    tabCloseRender = (): string => `\\\n</div>\n`,\n  } = options ?? {};\n\n  const tabsDataGetter = getTabsDataGetter(name);\n\n  md.block.ruler.before(\"fence\", `${name}_tabs`, getTabsRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.block.ruler.before(\"paragraph\", `${name}_tab`, getTabRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[`${name}_tabs_open`] = (\n    tokens,\n    index,\n    options,\n    env,\n    self,\n  ): string => {\n    const info = tabsDataGetter(tokens, index);\n\n    return openRender(info, tokens, index, options, env, self);\n  };\n\n  md.renderer.rules[`${name}_tabs_close`] = closeRender;\n\n  md.renderer.rules[`${name}_tab_open`] = (tokens, index, ...args): string => {\n    const data = tabDataGetter(tokens, index);\n\n    return tabOpenRender(data, tokens, index, ...args);\n  };\n\n  md.renderer.rules[`${name}_tab_close`] = tabCloseRender;\n};\n"],"names":["a","e","isSpace","code","MIN_MARKER_NUM","TAB_MARKER","ACTIVE_TAB_MARKER","TAB_MARKER_LENGTH","ACTIVE_TAB_MARKER_LENGTH","checkTabMarker","state","start","max","pos","isActive","markerEnd","infoStart","getTabRule","name","store","startLine","endLine","silent","indent","tabMatch","nextLine","autoClosed","nextLineStart","oldParent","oldLineMax","oldBlkIndent","openToken","infoEnd","escapePos","title","id","closeToken","getTabsRule","markerCount","i","hasId","char","idStart","nextLineMax","oldState","markup","idEnd","getTabsDataGetter","tokens","index","data","activeIndex","isTabStart","nestingDepth","block","meta","type","info","tabDataGetter","tab","md","options","openRender","_options","_env","self","active","token","tabs","escapeHtml","closeRender","tabOpenRender","tabCloseRender","tabsDataGetter","env","args"],"mappings":"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","x_google_ignoreList":[1]}