{"version":3,"file":"index.js","sources":["../src/plugins.ts"],"sourcesContent":["import type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\n\nimport type { MarkdownItAlertOptions } from \"./options.js\";\n\nconst getAlertRule =\n  (types: Set<string>, deep: boolean): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    if (\n      // if it's indented more than 3 spaces, it should be a code block\n      state.sCount[startLine] - state.blkIndent >= 4 ||\n      // check whether it's at first level\n      (state.level !== 0 && !deep)\n    )\n      return false;\n\n    const pos = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n\n    // check the block quote marker\n    if (state.src.charCodeAt(pos) !== 62 /* > */) return false;\n\n    let currentPos = pos + 1;\n\n    let initial = state.sCount[startLine] + 1;\n    let adjustTab = false;\n\n    // skip one optional space after '>'\n    if (state.src.charCodeAt(currentPos) === 32 /* space */) {\n      // ' >   [!tip] '\n      //     ^ -- position start of line here:\n      currentPos++;\n      initial++;\n    } else if (state.src.charCodeAt(currentPos) === 9 /* tab */) {\n      if ((state.bsCount[startLine] + initial) % 4 === 3) {\n        // '  >\\t  [!tip] '\n        //       ^ -- position start of line here (tab has width===1)\n        currentPos++;\n        initial++;\n      } else {\n        // ' >\\t  [!tip] '\n        //    ^ -- position start of line here + shift bsCount slightly\n        //         to make extra space appear\n        adjustTab = true;\n      }\n    }\n\n    let offset = initial;\n\n    while (currentPos < max) {\n      const ch = state.src.charCodeAt(currentPos);\n\n      if (ch === 9 /** \\t */)\n        offset +=\n          4 - ((offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4);\n      else if (ch === 32 /** space */) offset++;\n      else break;\n\n      currentPos++;\n    }\n\n    // skip blockquote\n    if (offset - initial >= 4) return false;\n\n    // the minimum length of an alert is 4 characters [!x]\n    if (max - currentPos < 4) return false;\n\n    // check opening marker '[!'\n    if (\n      state.src.charCodeAt(currentPos) !== 91 /* [ */ ||\n      state.src.charCodeAt(currentPos + 1) !== 33 /* ! */\n    )\n      return false;\n\n    currentPos += 2;\n\n    let typeName = \"\";\n\n    // find closing bracket ']'\n    while (currentPos < max) {\n      const char = state.src.charAt(currentPos);\n\n      if (char === \"]\") break;\n\n      typeName += char;\n      currentPos++;\n    }\n\n    if (currentPos === max) return false;\n\n    const type = typeName.toLowerCase();\n\n    if (!types.has(type)) return false;\n\n    // skip spaces after ']'\n    currentPos = state.skipSpaces(currentPos + 1);\n\n    // if there are non-space characters after ']', it's not a valid alert\n    if (currentPos < max) return false;\n\n    const oldBMarks: number[] = [];\n    const oldBSCount: number[] = [];\n    const oldSCount: number[] = [];\n    const oldTShift: number[] = [];\n    const oldLineMax = state.lineMax;\n    const oldParentType = state.parentType;\n    const terminatorRules = [\n      state.md.block.ruler.getRules(\"blockquote\"),\n      state.md.block.ruler.getRules(\"alert\"),\n    ].flat();\n\n    // @ts-expect-error: We are creating a new type called \"alert\"\n    state.parentType = \"alert\";\n\n    // Search the end of the block\n    //\n    // Block ends with either:\n    //  1. an empty line outside:\n    //     ```\n    //     > test\n    //\n    //     ```\n    //  2. an empty line inside:\n    //     ```\n    //     >\n    //     test\n    //     ```\n    //  3. another tag:\n    //     ```\n    //     > test\n    //      - - -\n    //     ```\n    let currentLine = startLine;\n\n    for (; currentLine < endLine; currentLine++) {\n      // check if it's outdented, i.e. it's inside list item and indented\n      // less than said list item:\n      //\n      // ```\n      // 1. anything\n      //    > current blockquote\n      // 2. checking this line\n      // ```\n      const isOutdented = state.sCount[currentLine] < state.blkIndent;\n\n      let pos = state.bMarks[currentLine] + state.tShift[currentLine];\n      const max = state.eMarks[currentLine];\n\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      if (pos >= max) break;\n\n      let lastLineEmpty = false;\n\n      if (state.src.charCodeAt(pos++) === 62 /* > */ && !isOutdented) {\n        // This line is inside the blockquote.\n\n        // set offset past spaces and \">\"\n        let initial = state.sCount[currentLine] + 1;\n        let spaceAfterMarker = false;\n        let adjustTab = false;\n\n        // skip one optional space after '>'\n        if (state.src.charCodeAt(pos) === 32 /* space */) {\n          // ' >   test '\n          //     ^ -- position start of line here:\n          pos++;\n          initial++;\n          spaceAfterMarker = true;\n        } else if (state.src.charCodeAt(pos) === 9 /* \\t */) {\n          spaceAfterMarker = true;\n\n          if ((state.bsCount[currentLine] + initial) % 4 === 3) {\n            // '  >\\t  test '\n            //       ^ -- position start of line here (tab has width===1)\n            pos++;\n            initial++;\n          } else {\n            // ' >\\t  test '\n            //    ^ -- position start of line here + shift bsCount slightly\n            //         to make extra space appear\n            adjustTab = true;\n          }\n        }\n\n        let offset = initial;\n\n        if (!silent) {\n          oldBMarks.push(state.bMarks[currentLine]);\n          state.bMarks[currentLine] = pos;\n        }\n\n        while (pos < max) {\n          const ch = state.src.charCodeAt(pos);\n\n          if (ch === 9 /** \\t */)\n            offset +=\n              4 -\n              ((offset + state.bsCount[currentLine] + (adjustTab ? 1 : 0)) % 4);\n          else if (ch === 32 /** space */) offset++;\n          else break;\n\n          pos++;\n        }\n\n        lastLineEmpty = pos >= max;\n\n        if (!silent) {\n          oldBSCount.push(state.bsCount[currentLine]);\n          state.bsCount[currentLine] =\n            state.sCount[currentLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n          oldSCount.push(state.sCount[currentLine]);\n          state.sCount[currentLine] = offset - initial;\n\n          oldTShift.push(state.tShift[currentLine]);\n          state.tShift[currentLine] = pos - state.bMarks[currentLine];\n        }\n        continue;\n      }\n\n      // Case 2: line is not inside the blockquote, and the last line was empty.\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (lastLineEmpty) break;\n\n      // Case 3: another tag found.\n      let terminate = false;\n\n      for (const terminatorRule of terminatorRules)\n        if (terminatorRule(state, currentLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n\n      if (terminate) {\n        // Quirk to enforce \"hard termination mode\" for paragraphs;\n        // normally if you call `tokenize(state, startLine, nextLine)`,\n        // paragraphs will look below nextLine for paragraph continuation,\n        // but if blockquote is terminated by another tag, they shouldn't\n        state.lineMax = currentLine;\n\n        if (state.blkIndent !== 0 && !silent) {\n          // state.blkIndent was non-zero, we now set it to zero,\n          // so we need to re-calculate all offsets to appear as\n          // if indent wasn't changed\n          oldBMarks.push(state.bMarks[currentLine]);\n          oldBSCount.push(state.bsCount[currentLine]);\n          oldSCount.push(state.sCount[currentLine]);\n          oldTShift.push(state.tShift[currentLine]);\n\n          state.sCount[currentLine] -= state.blkIndent;\n        }\n\n        break;\n      }\n\n      if (!silent) {\n        oldBMarks.push(state.bMarks[currentLine]);\n        oldBSCount.push(state.bsCount[currentLine]);\n        oldSCount.push(state.sCount[currentLine]);\n        oldTShift.push(state.tShift[currentLine]);\n\n        // A negative indentation means that this is a paragraph continuation\n        state.sCount[currentLine] = -1;\n      }\n    }\n\n    const restoreState = (): void => {\n      state.lineMax = oldLineMax;\n      state.parentType = oldParentType;\n\n      // Restore original tShift; this might not be necessary since the parser\n      // has already been here, but just to make sure we can do that.\n      for (let i = 0; i < oldTShift.length; i++) {\n        state.bMarks[i + startLine] = oldBMarks[i];\n        state.tShift[i + startLine] = oldTShift[i];\n        state.sCount[i + startLine] = oldSCount[i];\n        state.bsCount[i + startLine] = oldBSCount[i];\n      }\n    };\n\n    // If we didn't find any alert body, so we don't have a valid alert\n    if (startLine + 1 >= currentLine) {\n      // If we are in silent mode, we don't need to restore the state\n      if (!silent) restoreState();\n\n      return false;\n    }\n\n    // from now we know that it's going to be a valid alert,\n    // so no point trying to find the end of it in silent mode\n    if (silent) return true;\n\n    const oldIndent = state.blkIndent;\n\n    state.blkIndent = 0;\n\n    const titleLines: [number, number] = [startLine, startLine + 1];\n    const contentLines: [number, number] = [startLine + 1, 0];\n\n    const openToken = state.push(\"alert_open\", \"div\", 1);\n\n    openToken.markup = type;\n    openToken.attrJoin(\"class\", `markdown-alert markdown-alert-${type}`);\n    openToken.map = contentLines;\n\n    const titleToken = state.push(\"alert_title\", \"\", 0);\n\n    titleToken.attrJoin(\"class\", `markdown-alert-title`);\n    titleToken.markup = type;\n    titleToken.content = typeName;\n    titleToken.map = titleLines;\n\n    state.md.block.tokenize(state, startLine + 1, currentLine);\n\n    const closeToken = state.push(\"alert_close\", \"div\", -1);\n\n    closeToken.markup = type;\n    contentLines[1] = state.line;\n\n    state.blkIndent = oldIndent;\n    restoreState();\n\n    return true;\n  };\n\nexport const alert: PluginWithOptions<MarkdownItAlertOptions> = (\n  md,\n  {\n    alertNames = [\"tip\", \"warning\", \"caution\", \"important\", \"note\"],\n    deep = false,\n    openRender,\n    closeRender,\n    titleRender,\n  } = {},\n) => {\n  md.block.ruler.before(\n    \"blockquote\",\n    \"alert\",\n    getAlertRule(new Set(alertNames.map((name) => name.toLowerCase())), deep),\n    {\n      alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    },\n  );\n\n  if (openRender) md.renderer.rules.alert_open = openRender;\n  if (closeRender) md.renderer.rules.alert_close = closeRender;\n\n  md.renderer.rules.alert_title =\n    titleRender ??\n    ((tokens, index): string => {\n      const token = tokens[index];\n\n      return `<p class=\"markdown-alert-title\">${\n        token.content[0].toUpperCase() + token.content.slice(1).toLowerCase()\n      }</p>\\n`;\n    });\n};\n"],"names":["getAlertRule","types","deep","state","startLine","endLine","silent","pos","max","currentPos","initial","adjustTab","offset","ch","typeName","char","type","oldBMarks","oldBSCount","oldSCount","oldTShift","oldLineMax","oldParentType","terminatorRules","currentLine","isOutdented","lastLineEmpty","spaceAfterMarker","terminate","terminatorRule","restoreState","i","oldIndent","titleLines","contentLines","openToken","titleToken","closeToken","alert","md","alertNames","openRender","closeRender","titleRender","name","tokens","index","token"],"mappings":"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"}