var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/index.js
var lib_exports = {};
__export(lib_exports, {
  RawUrl: () => RawUrl,
  Url: () => Url,
  version: () => version
});
module.exports = __toCommonJS(lib_exports);

// node_modules/punycode/punycode.es6.js
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7F]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
var basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
var digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
var adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var decode = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
var encode = function(input) {
  const output = [];
  input = ucs2decode(input);
  const inputLength = input.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
var toUnicode = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
};
var toASCII = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
};
var punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.1.0",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6_default = punycode;

// node_modules/spec-url/src/pct.js
var [h2, h3, h4, h5] = [2 << 6, 6 << 5, 14 << 4, 30 << 3];
var [t6, t5, t4, t3] = [~(-1 << 6), ~(-1 << 5), ~(-1 << 4), ~(-1 << 3)];
var utf8 = {
  encode(code) {
    if (code < 128)
      return [code];
    else if (code < 2048) {
      const [c1, c2] = [code >> 6, code & t6];
      return [h3 | t5 & c1, h2 | t6 & c2];
    } else if (code < 65536) {
      const [c1, c2, c3] = [code >> 12, code >> 6, code & t6];
      return [h4 | t4 & c1, h2 | t6 & c2, h2 | t6 & c3];
    } else {
      const [c1, c2, c3, c4] = [code >> 18, code >> 12, code >> 6, code & t6];
      return [h5 | t3 & c1, h2 | t6 & c2, h2 | t6 & c3, h2 | t6 & c4];
    }
  },
  decode(bytes) {
    const codes = [];
    let n = 0, code = 0, err = false;
    for (let i = 0, l = bytes.length; i < l; i++) {
      const b = bytes[i];
      [err, n, code] = b >= 248 ? [1, 0, 0] : b >= 240 ? [n, 3, b & 7] : b >= 224 ? [n, 2, b & 15] : b >= 192 ? [n, 1, b & 31] : b >= 128 ? [!n, n - 1, code << 6 | b & 63] : [n, 0, b];
      if (err)
        throw new Error(`Invalid UTF8, at index ${i}`);
      if (n === 0)
        codes[codes.length] = code;
    }
    if (n)
      throw new Error(`Incomplete UTF8 byte sequence`);
    return codes;
  }
};
var pct = {
  encode(input, encodeSet, { ascii = true, incremental = true } = {}) {
    let coded = "";
    for (let char of input) {
      let cp = char.codePointAt(0);
      if (55296 <= cp && cp <= 56319 || 56320 <= cp && cp <= 57343)
        cp = 65533;
      const escapeAscii = ascii && (cp < 32 || cp > 126);
      const escapePct = !incremental && cp === 37;
      if (escapePct || escapeAscii || lookup(cp) & encodeSet)
        for (let byte of utf8.encode(cp)) {
          let h1 = byte >> 4, h22 = byte & 15;
          h1 = (h1 < 10 ? 48 : 55) + h1;
          h22 = (h22 < 10 ? 48 : 55) + h22;
          coded += String.fromCharCode(37, h1, h22);
        }
      else
        coded += char;
    }
    return coded;
  },
  decode(input) {
    return input.replace(_pcts, _decode);
  }
};
var _pcts = /(%[0-9A-Fa-f]{2})+/g;
var _decode = (input) => {
  const bytes = [];
  for (let i = 0, l = input.length; i < l; i += 3)
    bytes[bytes.length] = parseInt(input.substr(i + 1, 2), 16);
  return String.fromCodePoint(...utf8.decode(bytes));
};
var lookup;
var isInSet;
var getProfile;
{
  const url2 = 1 << 9, user2 = 1 << 8, host2 = 1 << 7, dir = 1 << 6, dir_s = 1 << 5, dir_ms = 1 << 4, dir_m = 1 << 3, query = 1 << 2, query_s = 1 << 1, hash = 1 << 0;
  const u20_u27 = [
    /* ( ) */
    999,
    /* (!) */
    0,
    /* (") */
    871,
    /* (#) */
    1022,
    /* ($) */
    0,
    /* (%) */
    512,
    /* (&) */
    0,
    /* (') */
    2
  ];
  const u2f = [
    /* (/) */
    504
  ];
  const u3A_u40 = [
    /* (:) */
    384,
    /* (;) */
    256,
    /* (<) */
    999,
    /* (=) */
    256,
    /* (>) */
    999,
    /* (?) */
    504,
    /* (@) */
    384
  ];
  const u5B_u60 = [
    /* ([) */
    896,
    /* (\) */
    944,
    /* (]) */
    896,
    /* (^) */
    896,
    /* (_) */
    0,
    /* (`) */
    865
  ];
  const u7B_u7E = [
    /* ({) */
    864,
    /* (|) */
    768,
    /* (}) */
    864,
    /* (~) */
    0
  ];
  lookup = (c) => (
    // Escape C0 controls, DEL and C1 controls
    c <= 31 || 127 <= c && c < 160 ? ~0 : (
      // Lookup tables
      32 <= c && c <= 39 ? u20_u27[c - 32] : c === 47 ? u2f[c - 47] : 58 <= c && c <= 64 ? u3A_u40[c - 58] : 91 <= c && c <= 96 ? u5B_u60[c - 91] : 123 <= c && c <= 126 ? u7B_u7E[c - 123] : (
        // Escape surrogate halves and non-characters
        55296 <= c && c <= 57343 ? ~0 : 64976 <= c && c <= 65007 || (c >> 1 & 32767) === 32767 ? ~0 : 0
      )
    )
  );
  const [username, pass2, password, file] = [user2, user2, user2, dir];
  const _generic = { url: url2, user: user2, pass: pass2, username, password, host: host2, dir, file, query, hash }, _minimal = { ..._generic, dir: dir_m, file: dir_m }, _special = { ..._generic, dir: dir_s, file: dir_s, query: query_s }, _minspec = { ..._generic, dir: dir_ms, file: dir_ms, query: query_s };
  getProfile = ({ minimal = false, special = false }) => minimal && special ? _minspec : special ? _special : minimal ? _minimal : _generic;
}
isInSet = (cp, { name, minimal, special }) => lookup(cp) & getProfile({ minimal, special })[name];

// node_modules/spec-url/src/host.js
var log = console.log.bind(console);
var _nonhost = /[\x00\x09\x0A\x0D\x20#%/:<>?@[\\\]^|]/g;
function parseHost(input, mode, percentCoded = true) {
  if (input) {
    if (input[0] === "[") {
      input = input.substr(1, input.length - 2);
      input = `[${ipv6.normalise(input)}]`;
    } else if (mode & 3) {
      let r = percentCoded ? pct.decode(input) : input;
      r = nameprep(r);
      r = punycode_es6_default.toUnicode(r);
      const address = ipv4.parse(r);
      if (address != null)
        return ipv4.print(address);
      if (!r.length || (_nonhost.lastIndex = 0, _nonhost.test(r)))
        throw new Error(`Host parser: Invalid domain: ${JSON.stringify(r)}`);
      return r;
    }
  }
  return input;
}
var tableB1 = /[\u00AD\u034F\u1806\uFEFF\u2060\u180B-\u180D\u200B-\u200D\uFE00-\uFE0F]/g;
var tableC6 = /[\uFFF9-\uFFFD]/g;
function nameprep(input) {
  tableC6.lastIndex = tableB1.lastIndex = 0;
  input = input.replace(tableB1, "").normalize("NFKC").toLowerCase();
  for (let c of input) {
    c = c.codePointAt(0);
    const nonchar = 64976 <= c && c <= 65007 || c <= 1114111 && (c >> 1 & 32767) === 32767;
    if (nonchar)
      throw new Error("Nameprep: Invalid code point");
  }
  if (tableC6.test(input))
    throw new Error("Nameprep: Invalid code point");
  return input;
}
var _ip4num = /(?:0[xX]([0-9A-Fa-f]*)|(0[0-7]*)|([1-9][0-9]*))([.]?)/y;
var ipv4 = {
  parse(input) {
    _ip4num.lastIndex = 0;
    let addr = 0, count = 0;
    let match, err = false;
    while (match = _ip4num.exec(input)) {
      count++;
      const num = match[1] != null ? parseInt(match[1] || "0", 16) : match[2] ? parseInt(match[2], 8) : parseInt(match[3], 10);
      if (_ip4num.lastIndex === input.length) {
        const rest = 5 - count;
        if (err || num >= 256 ** rest)
          throw new RangeError(`Invalid IPv4 address: <${input}>`);
        return (addr << 8 * rest) + num;
      } else {
        if (count === 4 || !match[4])
          return null;
        err = err || num > 255;
        addr = (addr << 8) + num;
      }
    }
    return null;
  },
  print(num) {
    let r = "";
    for (let i = 3; i; i--)
      r += (num >> 8 * i & 255) + ".";
    return r + (num & 255);
  },
  normalise(input) {
    return ipv4.print(ipv4.parse(input));
  }
};
var _start = /([0-9]+)([.])|([0-9A-Fa-f]+)(:?)|(::)/y;
var _hex = /([0-9]+)([.])|([0-9A-Fa-f]+)(:?)|(:)/y;
var _dec = /([0-9]+)([.])?/y;
var ipv6 = {
  parse(input) {
    const parts = [], ip4 = [];
    let match, compress = null;
    let rx = _start, p = rx.lastIndex = 0;
    while (match = rx.exec(input)) {
      p = rx.lastIndex;
      if (match[1]) {
        ip4.push(+match[1]);
        if (!match[2])
          break;
        rx = _dec;
      } else if (match[3]) {
        parts.push(parseInt(match[3], 16));
        if (!match[4])
          break;
        rx = _hex;
      } else if (match[5]) {
        if (compress == null)
          compress = parts.length;
        else
          throw new SyntaxError(`Invalid IPv6 address: [${input}]`);
        rx = _hex;
      }
      rx.lastIndex = p;
    }
    if (p !== input.length || ip4.length && ip4.length !== 4)
      throw new SyntaxError(`Invalid IPv6 address: [${input}]`);
    if (ip4.length) {
      const [n1, n2, n3, n4] = ip4;
      parts.push(256 * n1 + n2, 256 * n3 + n4);
    }
    if (compress == null && parts.length !== 8)
      throw new SyntaxError(`Invalid IPv6 address: [${input}]`);
    const a = [], l = 8 - parts.length;
    for (let i = 0; i < l; i++)
      a.push(0);
    return parts.splice(compress, 0, ...a), parts;
  },
  print(parts) {
    let [s0, l0] = [0, 0];
    let [s1, l1] = [0, 0];
    for (let i = 0, l = parts.length; i < l; i++) {
      let num = parts[i];
      if (num === 0)
        [s1, l1] = [i, 0];
      while (num === 0 && i < l)
        [i, l1, num] = [i + 1, l1 + 1, parts[i + 1]];
      if (l1 > l0)
        [s0, l0] = [s1, l1];
    }
    parts = parts.map((n) => n.toString(16));
    let c = s0 > 0 && s0 + l0 < 8 ? "" : s0 === 0 && l0 === 8 ? "::" : ":";
    if (l0 > 1)
      parts.splice(s0, l0, c);
    return parts.join(":");
  },
  normalise(input) {
    return ipv6.print(ipv6.parse(input));
  }
};

// node_modules/spec-url/src/index.js
var { setPrototypeOf: setProto, assign } = Object;
var ords = { scheme: 1, auth: 2, drive: 3, root: 4, dir: 5, file: 6, query: 7, hash: 8 };
var modes = { generic: 0, web: 1, file: 2, special: 3 };
var specials = { http: 1, https: 1, ws: 1, wss: 1, ftp: 1, file: 2 };
var modeFor = ({ scheme }, fallback = modes.generic) => specials[low(scheme)] || fallback;
var isFragment = (url2) => url2.hash != null && ord(url2) === ords.hash;
var low = (str) => str ? str.toLowerCase() : str;
var tags = {
  scheme: 1,
  user: 2,
  pass: 2,
  host: 2,
  port: 2,
  drive: 3,
  root: 4,
  dirs: 5,
  file: 6,
  query: 7,
  hash: 8
};
var ord = (url2) => {
  for (const k in tags)
    if (url2[k] != null)
      return tags[k];
  return ords.hash;
};
var upto = (url2, ord2) => {
  const r = {};
  for (const k in tags)
    if (url2[k] == null)
      continue;
    else if (tags[k] < ord2)
      r[k] = url2[k];
    else if (tags[k] === ord2 && k === "dirs")
      r[k] = url2[k].slice(0);
  return r;
};
var goto = (url1, url2) => {
  const r = upto(url1, ord(url2));
  for (const k in tags)
    if (url2[k] == null)
      continue;
    else if (k === "dirs")
      r.dirs = [...r.dirs || [], ...url2.dirs];
    else
      r[k] = url2[k];
  if ((r.host != null || r.drive) && (r.dirs || r.file))
    r.root = "/";
  return r;
};
var isBase = ({ scheme, host: host2, drive, root }) => {
  const mode = specials[low(scheme)] || modes.generic;
  return scheme && (mode & modes.file ? host2 != null && (drive || root) : mode & modes.web ? host2 && root : host2 != null || root);
};
var ForceError = class extends TypeError {
  constructor(url2) {
    super(`Cannot coerce ${print(url2)} to a base-URL`);
  }
};
var forceAsFileUrl = (url2) => {
  url2 = assign({}, url2);
  if (url2.host == null)
    url2.host = "";
  if (url2.drive == null)
    url2.root = "/";
  return url2;
};
var forceAsWebUrl = (url2) => {
  url2 = assign({}, url2);
  if (!url2.host) {
    let str = url2.host;
    const dirs = url2.dirs ? url2.dirs.slice() : [];
    while (!str && dirs.length)
      str = dirs.shift();
    if (!str) {
      str = url2.file;
      delete url2.file;
    }
    if (str) {
      try {
        assign(url2, parseAuth(str, modes.web));
      } catch (e) {
        throw new ForceError(url2);
      }
      if (dirs.length)
        url2.dirs = dirs;
      else
        delete url2.dirs;
    } else
      throw new ForceError(url2);
  }
  url2.root = "/";
  return url2;
};
var force = (url2) => {
  const mode = specials[low(url2.scheme)] || modes.generic;
  if (mode === modes.file)
    return forceAsFileUrl(url2);
  else if (mode === modes.web)
    return forceAsWebUrl(url2);
  else if (url2.scheme)
    return url2;
  else
    throw new ForceError(url2);
};
var ResolveError = class extends TypeError {
  constructor(url1, url2) {
    super(`Cannot resolve <${print(url1)}> against <${print(url2)}>`);
  }
};
var genericResolve = (url1, url2) => {
  if (url1.scheme || url2.scheme)
    return goto(url2, url1);
  else
    throw new ResolveError(url1, url2);
};
var legacyResolve = (url1, url2) => {
  if (url1.scheme && low(url1.scheme) === low(url2.scheme))
    url2 = setProto({ scheme: url1.scheme }, url2), url1 = setProto({ scheme: null }, url1);
  return genericResolve(url1, url2);
};
var WHATWGResolve = (url1, url2) => {
  const mode = url1.scheme ? modeFor(url1) : modeFor(url2);
  if (mode & modes.special)
    return force(legacyResolve(url1, url2));
  if (isBase(url2))
    return genericResolve(url1, url2);
  if (url2.scheme && (url1.scheme || isFragment(url1)))
    return goto(url2, url1);
  else
    throw new ResolveError(url1, url2);
};
var normalise = (url2, coded = true) => {
  const r = assign({}, url2);
  const scheme = low(r.scheme);
  r.scheme = scheme;
  if (r.pass === "")
    delete r.pass;
  if (!r.pass && r.user === "")
    delete r.user;
  if (r.port === "")
    delete r.port;
  if (!isBase(url2) && url2.dirs)
    r.dirs = r.dirs.slice();
  else {
    const dirs = [];
    for (const x of r.dirs || []) {
      const isDots = dots(x, coded);
      if (isDots === 2)
        dirs.pop();
      else if (!isDots)
        dirs.push(x);
    }
    if (r.file) {
      const isDots = dots(r.file, coded);
      if (isDots === 2)
        dirs.pop();
      if (isDots)
        delete r.file;
    }
    if (dirs.length)
      r.dirs = dirs;
    else
      delete r.dirs;
  }
  if (r.drive)
    r.drive = r.drive[0] + ":";
  if (scheme === "file" && r.host === "localhost")
    r.host = "";
  else if (url2.port === 80 && (scheme === "http" || scheme === "ws"))
    delete r.port;
  else if (url2.port === 443 && (scheme === "https" || scheme === "wss"))
    delete r.port;
  else if (url2.port === 21 && scheme === "ftp")
    delete r.port;
  for (const k in tags)
    if (r[k] == null)
      delete r[k];
  return r;
};
var dots = (seg, coded = true) => seg.length <= 3 && (seg === "." || coded && low(seg) === "%2e") ? 1 : seg.length <= 6 && (seg === ".." || coded && low(seg) === ".%2e" || coded && low(seg) === "%2e." || coded && low(seg) === "%2e%2e") ? 2 : 0;
var percentEncode = (url2, options = { ascii: true }) => {
  const r = {}, profile = profileFor(url2);
  for (const k in tags)
    if (url2[k] != null) {
      const v = url2[k];
      if (k === "dirs") {
        const _dirs = r.dirs = [];
        for (const x of v)
          _dirs.push(pct.encode(x, profile.dir, options));
      } else if (k === "host") {
        if (_isIp6(v))
          r[k] = v;
        else if (modeFor(url2) & modes.special)
          r[k] = options.ascii ? punycode_es6_default.toASCII(v) : v;
        else
          r[k] = pct.encode(v, profile[k], options);
      } else
        r[k] = k in profile ? pct.encode(v, profile[k], options) : v;
    }
  return r;
};
var _decode2 = getProfile({});
var percentDecode = (url2) => {
  const r = {};
  for (let k in tags)
    if (url2[k] != null)
      r[k] = k === "dirs" ? url2[k].map(pct.decode) : k in _decode2 ? pct.decode(url2[k]) : url2[k];
  return r;
};
var _isIp6 = (str) => str != null && str[0] === "[" && str[str.length - 1] === "]";
var profileFor = (url2, fallback) => {
  const special = modeFor(url2, fallback) & modes.special;
  const minimal = special ? false : !isBase(url2);
  return getProfile({ minimal, special });
};
var print = (url2) => {
  const driveNorAuth = !url2.drive && url2.host == null;
  const emptyFirstDir = url2.dirs && url2.dirs[0] === "";
  if (driveNorAuth && url2.root && emptyFirstDir || !url2.root && emptyFirstDir)
    url2 = setProto({ dirs: ["."].concat(url2.dirs) }, url2);
  return _print(url2);
};
var _print = (url2) => {
  let result = "";
  const hasCreds = url2.user != null;
  for (const k in tags)
    if (url2[k] != null) {
      const v = url2[k];
      result += k === "scheme" ? v + ":" : k === "user" ? "//" + v : k === "pass" ? ":" + v : k === "host" ? (hasCreds ? "@" : "//") + v : k === "port" ? ":" + v : k === "drive" ? "/" + v : k === "root" ? "/" : k === "dirs" ? v.join("/") + "/" : k === "file" ? v : k === "query" ? "?" + v : k === "hash" ? "#" + v : "";
    }
  return result;
};
function* flags(a = 0, z = 30) {
  while (a <= z)
    yield 1 << a++;
}
var [START, SCHEME, SS, AUTH, PATH, QUERY, FRAG] = flags();
var [CR, LF, TAB, SP, QUE, HASH, COL, PLUS, MIN, DOT, SL, SL2, BAR] = [..."\r\n	 ?#:+-./\\|"].map((_) => _.charCodeAt(0));
var isAlpha = (c) => 65 <= c && c <= 90 || 97 <= c && c <= 122;
function parse(input, mode = modes.web) {
  const url2 = {};
  let state = START | SCHEME;
  let slashes = 0, letter = false, isDrive = false;
  let buffer = "", end = 0;
  for (let i = 0, l = input.length; i <= l; i++) {
    const c = input.charCodeAt(i);
    if (c === CR || c === LF || c === TAB || state & START && c <= SP)
      continue;
    if (isNaN(c))
      buffer = buffer.substr(0, end);
    const isSlash = c === SL || mode & modes.special && c === SL2;
    if (isSlash && state & (START | SS)) {
      state = ++slashes === 2 ? AUTH : SS;
      continue;
    }
    const isDelim = state === SCHEME && c === COL || state < QUERY && (isSlash || c === QUE) || state < FRAG && c === HASH || isNaN(c);
    if (isDelim) {
      if (state === SCHEME && c === COL) {
        url2.scheme = buffer;
        mode = modeFor(url2);
      } else if (state === SS) {
        if (isSlash || slashes)
          url2.root = "/";
      } else if (isDrive) {
        if (state & AUTH)
          url2.host = "";
        url2.drive = buffer;
        delete url2.root;
        if (isSlash)
          url2.root = "/";
      } else if (state & AUTH) {
        assign(url2, parseAuth(buffer, mode, true));
        if (isSlash)
          url2.root = "/";
      } else if (state === QUERY)
        url2.query = buffer;
      else if (state === FRAG)
        url2.hash = buffer;
      else if (isSlash)
        (url2.dirs = url2.dirs || []).push(buffer);
      else if (buffer)
        url2.file = buffer;
      state = c === COL ? SS : c === QUE ? QUERY : c === HASH ? FRAG : PATH;
      letter = isDrive = false;
      [buffer, end] = ["", 0];
      continue;
    }
    if (state & SCHEME && isAlpha(c))
      state = SCHEME;
    else if (state === SCHEME && (c !== PLUS && c !== MIN && c !== DOT) && (c < 48 || 57 < c))
      state = PATH;
    else if (state & (START | SS)) {
      if (slashes)
        url2.root = "/";
      state = PATH;
    }
    if (mode & modes.file && !url2.drive && !url2.dirs && state < QUERY) {
      isDrive = letter && (c === BAR || state & ~SCHEME && c === COL);
      letter = !buffer && isAlpha(c);
    } else
      isDrive = false;
    buffer += input[i];
    if (c > SP)
      end = buffer.length;
  }
  return url2;
}
var raw = String.raw;
var opt = (_) => "(?:" + _ + ")?";
var Rexp = (_) => new RegExp("^" + _ + "$");
var port = "[:]([0-9]*)";
var user = "([^:]*)";
var pass = "[:](.*)";
var host = raw`(\[[^\]]*\]|[^\0\t\n\r #/:<>?@[\\\]^|]*)`;
var creds = user + opt(pass) + "[@]";
var authExp = Rexp(opt(creds) + host + opt(port));
function parseAuth(input, mode, percentCoded = true) {
  let match, user2, pass2, host2, port2, _;
  if (input.length === 0)
    host2 = "";
  else if (match = authExp.exec(input)) {
    [_, user2, pass2, host2, port2] = match;
    if (port2 != null && port2.length) {
      port2 = +port2;
      if (port2 >= 2 ** 16)
        throw new Error("ERR_INVALID_PORT");
    }
  } else
    throw new Error("ERR_INVALID_AUTH");
  if ((user2 != null || port2 != null) && !host2)
    throw new Error();
  if (mode === modes.file && (user2 != null || port2 != null))
    throw new Error();
  host2 = parseHost(host2, mode, percentCoded);
  const auth = { user: user2, pass: pass2, host: host2, port: port2 };
  for (const k in auth)
    if (auth[k] == null)
      delete auth[k];
  return auth;
}

// lib/index.js
var log2 = console.log.bind(console);
var { setPrototypeOf: setProto2, freeze } = Object;
var Url = class _Url {
  constructor(obj = {}, { parser = "http" } = {}) {
    const r = prepare(obj, this, parser);
    return r instanceof _Url ? r : url({}, this).set(r);
  }
  get href() {
    return this.toString({ ascii: true });
  }
  get percentCoded() {
    return false;
  }
  // ### Goto
  goto(other) {
    other = prepare(other, this, this.scheme);
    return url(goto(this, other), this);
  }
  // ### Base URLs
  isBase() {
    return isBase(this);
  }
  forceAsFileUrl() {
    const r = forceAsFileUrl(this);
    return r === this ? this : url(r, this);
  }
  forceAsWebUrl() {
    const r = forceAsWebUrl(this);
    return r === this ? this : url(r, this);
  }
  force() {
    const r = force(this);
    return r === this ? this : url(r, this);
  }
  // ### Reference Resolution
  genericResolve(base2) {
    base2 = prepare(base2, this);
    return url(genericResolve(this, base2), this);
  }
  legacyResolve(base2) {
    base2 = prepare(base2, this);
    return url(legacyResolve(this, base2), this);
  }
  WHATWGResolve(base2) {
    base2 = prepare(base2, this);
    return url(WHATWGResolve(this, base2), this);
  }
  resolve(base2) {
    base2 = prepare(base2, this);
    return url(WHATWGResolve(this, base2), this);
  }
  // ### Normalisation
  normalise() {
    return url(normalise(this), this);
  }
  normalize() {
    return url(normalise(this), this);
  }
  // ### Percent Coding (Url <--> RawUrl)
  percentEncode({ ascii = true } = {}) {
    const options = { ascii, incremental: this.percentCoded };
    return url(percentEncode(this, options), { percentCoded: true });
  }
  percentDecode() {
    return this;
  }
  // ### Printing
  toString({ ascii = false } = {}) {
    const options = { ascii, incremental: this.percentCoded };
    return print(percentEncode(this, options));
  }
  toURI() {
    if (!isBase(this))
      throw new TypeError(`Cannot convert <${this}> to an URI because it has no scheme`);
    return this.toString({ ascii: true });
  }
  toASCII() {
    return this.toString({ ascii: true });
  }
  toJSON() {
    return this.toString({ ascii: true });
  }
  // ### Url.set
  set(patch) {
    if ("host" in patch) {
      const { user: user2 = null, pass: pass2 = null, port: port2 = null } = patch;
      patch = setProto2({ user: user2, pass: pass2, port: port2 }, patch);
    } else if ("user" in patch && !("pass" in patch))
      patch = setProto2({ pass: null }, patch);
    const { percentCoded = this.percentCoded } = patch;
    if (percentCoded !== this.percentCoded)
      patch = percentCoded ? percentDecode(patch) : percentEncode(patch, { incremental: false });
    const r = {};
    let errs = [];
    const setters = settersFor(r, errs, this.percentCoded);
    for (let k in setters)
      if (k in patch) {
        if (patch[k] != null)
          setters[k](patch[k]);
      } else if (k in this)
        r[k] = k === "dirs" ? [...this.dirs] : this[k];
    if (errs.length)
      throw new TypeError(`Invalid patch:
	- ${errs.join("\n	- ")}
`);
    if (!r.root) {
      if ((r.host != null || r.drive) && (r.dirs || r.file)) {
        if (r.root === null)
          throw new Error("Cannot unset path-root");
        else
          r.root = "/";
      } else
        delete r.root;
    }
    errs = structErrors(r);
    if (errs.length) {
      throw new TypeError(`	- ${errs.join("\n	- ")}
`);
    }
    return url(r, { percentCoded: this.percentCoded });
  }
};
var RawUrl = class extends Url {
  get percentCoded() {
    return true;
  }
  percentDecode() {
    return url(percentDecode(this), { percentCoded: false });
  }
};
function url(obj, { percentCoded = false } = {}) {
  if (obj.dirs)
    freeze(obj.dirs);
  return freeze(setProto2(obj, (percentCoded ? RawUrl : Url).prototype));
}
function prepare(obj, { percentCoded = false } = {}, scheme = "http") {
  if (typeof obj === "string") {
    obj = parse(obj, modeFor({ scheme }));
    return percentCoded ? obj : percentDecode(obj);
  } else if (obj && typeof obj === "object") {
    obj = obj instanceof Url ? obj : Url.prototype.set.call({}, obj);
    if (obj.percentCoded === percentCoded)
      return obj;
    else
      return percentCoded ? percentEncode(obj, { incremental: false }) : percentDecode(obj);
  }
  return {};
}
var settersFor = (r, errs, coded) => ({
  scheme: (v) => {
    if ((v = String(v)) && /^[a-zA-Z][a-zA-Z0-9.+-]*$/.test(v))
      r.scheme = v;
    else
      errs.push("Invalid scheme string");
  },
  user: (v) => r.user = String(v),
  pass: (v) => r.pass = String(v),
  host: (v) => r.host = parseHost(String(v), modeFor(r), coded),
  port: (v) => {
    if (v === "")
      r.port = v;
    else if ((v = +v) < 2 ** 16)
      r.port = v;
    else
      errs.push("Invalid port");
  },
  drive: (v) => {
    if ((v = String(v)) && /^[a-zA-Z][|:]?$/.test(v))
      r.drive = v.length > 1 ? v : v + ":";
    else
      errs.push("Invalid drive string");
  },
  // NB root may temporarily be set to null as a trick to preserve key-order. 
  // It will either be removed or replaced with '/' by the set method. 
  root: (v) => r.root = v ? "/" : null,
  dirs: (v) => {
    if (v && typeof v === "object" && Symbol.iterator in v) {
      const dirs = [];
      for (let x of v)
        dirs[dirs.length] = String(x);
      if (dirs.length)
        r.dirs = dirs;
    } else
      errs.push("Invalid dirs array");
  },
  file: (v) => {
    if (v = String(v))
      r.file = v;
    else
      errs.push("Invalid file string");
  },
  query: (v) => r.query = String(v),
  hash: (v) => r.hash = String(v)
});
var structErrors = (r) => {
  const errs = [];
  const isFile = !r.scheme && r.drive || r.scheme && modeFor(r) === modes.file;
  if ((r.host == null || isFile) && (r.user != null || r.pass != null || r.port != null))
    errs.push(isFile ? `A file-URL cannot have credentials or a port` : `A host-less URL cannot have credentials or a port`);
  else if (r.pass != null && r.user == null)
    errs.push(`A URL without username cannot have a password`);
  if (!isFile && r.drive)
    errs.push(`A non-file URL cannot have a drive`);
  return errs;
};
var version = "1.0.0-rc.2";
